Самое главное из этой статьи :" изменяемые аргументы по умолчанию
сохраняют свое состояние между вызовами функции"
И Если такое поведение является неприемлемым, можно просто создавать копию
аргумента по умолчанию в начале тела функции или переместить выражение,
возвращающее значение по умолчанию, в тело функции. Поскольку в этом
случае значение по умолчанию будет находиться в программном коде, кото-
рый выполняется при каждом вызове функции, вы всякий раз будете получать
новый объект:



Значения по умолчанию для аргументов функции вычисляются и запомина-
ются в момент выполнения инструкции def, а не при вызове функции. Внутрен-
няя реализация Python сохраняет по одному объекту для каждого аргумента
со значением по умолчанию, присоединенного к функции.
Вычисление значений по умолчанию в момент определения функции – это
чаще именно то, что вам требуется; это позволяет, в случае необходимости, со-
хранять значения из объемлющей области видимости. Но так как значения по
умолчанию сохраняются между вызовами функции, следует быть вниматель-
ным при воздействии на изменяемые значения по умолчанию. Например, сле-
дующая функция использует пустой список в качестве значения по умолчанию
своего аргумента, а затем изменяет его при каждом вызове:
>>> def saver(x=[]): # Объект списка сохраняется
... x.append(1) # При каждом вызове изменяется один и тот же объект!
... print(x)
...
>>> saver([2]) # Значение по умолчанию не используется
[2, 1]
>>> saver() # Используется значение по умолчанию
[1]
>>> saver() # Список растет при каждом вызове!
[1, 1]
>>> saver()
[1, 1, 1]
Некоторые воспринимают такое поведение как достоинство – изменяемые ар-
гументы по умолчанию сохраняют свое состояние между вызовами функции,
поэтому они могут играть роль, подобную роли статических локальных пере-
менных в языке C. В некотором смысле они ведут себя как глобальные пере-
менные за исключением того, что их имена являются локальными по отноше-
нию к функциям, вследствие чего исключается конфликт имен с переменны-
ми, определенными в другом месте.
Для большинства же это выглядит как недостаток, особенно для тех, кто впер-
вые сталкивается с этой особенностью. В языке Python существует лучший
способ сохранения состояния между вызовами функций (например, за счет ис-
пользования классов, которые будут рассматриваться в шестой части книги).
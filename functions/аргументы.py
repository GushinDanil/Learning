'''ВАЖНО ЗНАТЬ  '''
'''параметры функций строятся следующим образом
  (сначала позиционные элементы потом элементы со *  
  потом именованные аргументы 
  и в самом конце переменные с **)
  и нельзя писать аргументы со значением по умолчанию перед значениями не по умолчанию
  НО можно написать именованные аргументы перед позиционными аргументами
  
  '''


def func1(*args):
    print('calling func :', func1.__name__)
    print(args)


func1(1, 2, 3)
func1(*open('C:\\Users\\admin-1\\PycharmProjects\\Learning\\files\\text.txt'))
func1(1)


def func2(a, b, c):
    print('calling func :', func2.__name__)
    print(a, b, c)


func2(*[1, 2, 3])


def func3(a, *b, c):
    print('calling func :', func3.__name__)
    print(a, b, c)


func3(1, c=3)


def func4(a, b, c, d):
    print('calling func :', func4.__name__)
    print(a, b, c, d)


func4(1, *[2, 3], 4)

'''Комбинация ** дает похожий результат, но применяется при передаче имено-
ванных аргументов – в этом случае аргументы будут собраны в новый словарь,
который можно обрабатывать обычными инструментами, предназначенными
для работы со словарями. В определенном смысле форма ** позволяет преоб-
разовать аргументы, передаваемые по именам, в словари, которые можно будет
обойти с помощью метода keys, итераторов словарей и так далее: '''


def func5(**args):  # только именованные  аргументы (имена в последствии ключи)
    print('calling func :', func5.__name__)
    print(args)  # словарь


func5(a=1, b=2, c=3)


def func6(a, *parg, **karg):  # a(позиционный аргумент) в параментре функции должны находится перед переменной со *
    print('calling func :', func6.__name__)
    print(a, parg, karg)


func6(1, 2, 3, x=4, y=5)


def func7(a, b, c):
    print('calling func :', func7.__name__)

    print(a, b, c)


d = {'a': 1, 'b': 2, 'c': 3}
func7(**d)  # ключи должны быть строчные для **переменной

print('-' * 50)


def func(a, b, c, d):
    print(a + b + c + d)


def func8(f, parg, karg):
    print('calling func :', func8.__name__)
    return f(*parg, **karg)


func8(func, [1, 2], {'c': 3, 'd': 4})

print('-' * 50)

'''Чтобы показать, что функция не принимает списки аргументов произвольной
длины, можно использовать одиночный символ *, при этом она ожидает, что
все следующие за звездочкой аргументы будут передаваться по именам. Сле-
дующей функции аргумент a можно передать как позиционный или как име-
нованный, но аргументы b и c могут передаваться только как именованные
аргументы; при этом функция не может принимать списки аргументов произ-
вольной длины: '''


def func9(a, *, b, c):
    print('calling func :', func9.__name__)
    print(a, b, c)


func9(1, b=2, c=3)


def func10(a, *b, c=6, **d):
    print(a, b, c, d)


func10(1, 2, 3, **dict(x=4, y=5, c=100))  # именованные аргументы считываются внутри словаря по ключу

# **dict(x=4,y=5,c=100) - это выражение означает что мы получим не три элемента а три
# именованных аргумента в нашу функцию(такая запись возможна только в параметрах функций)


'''
Зачем нужны именованные аргументы(для удобства удобочистаемости и ещё
Следующее определение функции гарантирует, что ни один из позиционных аргументов не бу-
дет по ошибке сопоставлен с аргументом notify, и требует, чтобы этот параметр
передавался по имени:
def process(*args, notify=False): ...
потому что после переменной со * только именованные аргументы или **'''


def name_attrs(*,a,b,c): # запись означает что только именованные аргументы
    # (потому что после * только именованные аргументы или словари)
    return a+b+c

name_attrs(a=1,c=2,b=3)
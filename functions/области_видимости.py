'''не изменяй глобальные перемнные одного модуля внутри другого если
это очень надо сделать то сделай функцию сет для это переменной  импортируй её
хотя тоже такая себе практика '''
'''Важно не упускать из виду несколько моментов. Во-первых, в отличие от имен,
перечисленных в инструкции global, имена в инструкции nonlocal к момен-
ту объявления уже должны существовать в области видимости объемлющей
функции, в противном случае интерпретатор возбудит исключение – нельзя
создавать имена в объемлющей области видимости с помощью инструкции
присваивания

Во-вторых, инструкция nonlocal ограничивает область поиска имен перемен-
ных только областями видимости объемлющих функций – поиск нелокальных
переменных не производится за пределами инструкций def ни в глобальной об-
ласти видимости объемлющего модуля, ни во встроенной области видимости,
даже если переменные с такими именами там существуют:
>>> spam = 99
>>> def tester():
...
def nested():
...
nonlocal spam # Переменная должна быть внутри def, а не в модуле!
...
print(‘Current=’, spam)
...
spam += 1
...
return nested
...
SyntaxError: no binding for nonlocal ‘spam’ found
'''
x = 1


def test1():
    print(x)  # global


def test2():
    x = 10
    print(x)  # local


test1()
test2()

print(x)

print('-' * 50)

x = 1


def test3():
    global x  # глобальная переменная привязана к верхнему уровню модуля
    global y  # создал глобальную переменную внутри функции
    y = 88
    x = 999


test3()

y = 888
print(x, y)

print('-' * 50)
X = 99  # Имя в глобальной области видимости: не используется


def f1():
    X = 88  # Локальное имя в объемлющей функции

    def f2():
        """если бы небыло x=88 то вывело бы 99"""
        print(X)  # Обращение к переменной во вложенной функции

    f2()


f1()  # Выведет 88: локальная переменная в объемлющей функции
print('-' * 50)

'''
global вынуждает интерпретатор начинать поиск имен с области объемлю-
щего модуля и позволяет присваивать переменным новые значения. Об-
ласть поиска простирается вплоть до встроенной области видимости, если
искомое имя не будет найдено в модуле, при этом операция присваивания
значений глобальным именам всегда будет создавать или изменять пере-
менные в области видимости модуля.


nonlocal ограничивает область поиска областями видимости объемлющих
функций; она требует, чтобы перечисленные в инструкции имена уже су-
ществовали, и позволяет присваивать им новые значения. В область поиска
не входят глобальная и встроенная области видимости.'''

print('-' * 50)

'''Ниже описана причина использование переменных nonlocal(но наилучшее решение это классы)
дело в том что значение объекта при искпользовании глобальной переменной затирается так как оно 
оно принадлежит всем объектам функции одновременно() а значения объекта
nonlocal  уникальные для каждого объекта будто как объекты классов
поэтому юзать надо классы
'''


def func1(n):
    def func2(x):
        nonlocal n
        print(x, n)
        n += 1

    return func2


a = func1(1)
a('a')
a('b')
a('c')
print()
b = func1(101)
b('a')
b('b')
b('c')
a('d')

print('-' * 50)

state = 0


def func1(n):
    global state
    state = n

    def func2(x):
        global state
        print(x, state)
        state += 1

    return func2


a = func1(1)
a('a')
a('b')
a('c')
print()
b = func1(101)
b('a')
b('b')
b('c')
a('d')
print(isinstance([1], list))

print([[]], ["", [], ( ), {}, None])


"""Давайте рассмотрим на примере программного кода, как работают классы ис-
ключений. В следующем файле classexc.py определяется суперкласс с именем
General и два подкласса с именами Specific1 и Specific2. Этот пример иллюстри-
рует понятие категорий исключений, где General – это имя категории, а два под-
класса – это определенные типы исключений внутри категории. Обработчики,
которые перехватывают исключение General, так же будут перехватывать и все
его подклассы, в том числе Specific1 и Specific2:"""


class General(Exception):
    pass


class Specific1(General):
    pass


class Specific2(General):
    pass


def raiser0():
    raise General()


def raiser1():
    raise Specific1()


def raiser2():
    raise Specific2


for func in [raiser0, raiser1, raiser2]:
    try:
        func()
    except General as obj:  # Перехватывает исключения General и любые его подклассы
        import sys

        print("caught:", sys.exc_info()[0])
        print("caught:", obj.__class__.__name__)
        print(20 * '-')
"""В этом примере обработчик исключений использует функцию sys.exc_info –
как мы узнаем в следующей главе, эта функция обеспечивает обобщенный
способ получить последнее возбужденное исключение. В двух словах, пер-
вый элемент в полученном результате – это класс возбужденного исклю-
чения, а второй – фактический экземпляр исключения. В подобных пред-
ложениях except, перехватывающих все исключения, принадлежащие не-
которой категории, как в данном примере, функция sys.exc_info является
единственным способом точно определить, что произошло. В данном случае
ее можно рассматривать, как эквивалент обращения к атрибуту __class__
экземпляра. Как мы увидим в следующей главе, функция sys.exc_info часто
используется в обработчиках пустых предложений except, которые пере-
хватывают все возможные исключения."""

"""Так как тип исключения можно определить с помощью атрибута __class__ воз-
бужденного экземпляра исключения, как в данном примере, функцию sys.exc_
info удобнее использовать в обработчиках пустых предложений except, где нет
другого способа получить доступ к экземпляру или к его классу. Кроме того,
в действующих программах обычно не приходится беспокоиться о конкретном
типе возбужденного исключения – вызывая методы экземпляра, мы автома-
тически получаем поведение, присущее возбужденному исключению. Подроб-
нее об этом и о функции sys.exc_info будет рассказываться в следующей главе.
Кроме того, если вы забыли назначение атрибута __class__ в экземплярах, об-
ращайтесь к главе 28 и ко всей шестой части в целом."""

"""Операция вывода по умолчанию
и сохранение информации
Встроенные исключения предоставляют реализацию вывода сообщения, ис-
пользуемую по умолчанию, и сохранение информации о состоянии, что обеспе-
чивает значительную долю логики работы исключений, в которых нуждаются
пользовательские классы. Если, наследуя встроенные классы исключений, вы
не переопределяете конструктор суперкласса, любые аргументы, передавае-
мые конструктору, будут сохраняться в атрибуте args экземпляра и автомати-
чески включаться в текст сообщения при выводе экземпляра (если конструк-
тор вызывался без аргументов, будут выведены пустой кортеж и стандартная
строка сообщения).
Это объясняет, почему аргументы, передаваемые конструкторам классов встро-
енных исключений, включаются в текст сообщения об ошибке – все аргументы
присоединяются конструктором к экземпляру и отображаются при попытке
вывести его:

>>> raise IndexError # То же, что и IndexError(): нет аргументов
Traceback (most recent call last):
File “<stdin>”, line 1, in <module>
IndexError
>>> raise IndexError(‘spam’) # Конструктор присоединит аргумент
Traceback (most recent call last):
File “<stdin>”, line 1, in <module>
IndexError: spam
>>> I = IndexError(‘spam’) # Аргументы доступны в виде атрибута
>>> I.args
(‘spam’,)


То же относится и к пользовательским исключениям, потому что они наследу-
ют от встроенных суперклассов конструктор и методы вывода:
>>> class E(Exception): pass
...
>>> try:
... raise E(‘spam’)
... except E as X:
... print(X, X.args) # Выведет аргументы, сохраненные конструктором
...
spam (‘spam’,)
>>> try:
... raise E(‘spam’, ‘eggs’, ‘ham’)
... except E as X:
... print(X, X.args)
...
(‘spam’, ‘eggs’, ‘ham’) (‘spam’, ‘eggs’, ‘ham’)


Обратите внимание, что объекты экземпляров исключений сами по себе не яв-
ляются строками, но они используют протокол перегрузки операторов, кото-
рый мы изучали в главе 29, и реализуют метод __str__, обеспечивающий преоб-
разование экземпляра в строку. Чтобы выполнить конкатенацию экземпляра
с настоящей строкой, его необходимо вручную преобразовать в строковое пред-
ставление: str(X) + “string”.
Автоматическая поддержка вывода и сохранения информации удобна сама по
себе, тем не менее, чтобы организовать сохранение дополнительной информа-
ции и вывод специфических сообщений, вы всегда можете переопределить уна-
следованные методы, такие как __str__ и __init__, в подклассах класса Exception,
о чем рассказывается в следующем разделе."""

"""Помимо возможности передавать дополнительную информацию о состоянии
адаптированные классы могут использоваться для реализации специфиче-
ского поведения объектов исключений. То есть класс исключения может опре-
делять дополнительные методы для использования в обработчиках. Ниже
приводится пример класса исключения, который реализует дополнительный
метод, использующий информацию о состоянии для регистрации ошибки
в файле:"""


class FormatError(Exception):
    logfile = 'logerror.txt'

    def __init__(self, line, file):
        self.file = file
        self.line = line

    def logError(self):
        file = open(self.logfile, 'a')
        print('Error at {0} the reason is {1}'.format(self.file, self.line), file=file)
        file.close()


def parser():
    raise FormatError(40, 'spam.txt')


try:
    parser()
except FormatError as error:
    error.logError()

"""При использовании подобных классов методы (такие, как loggeror) могут
наследоваться
подклассами, а атрибуты экземпляра (такие, как line и file)
предоставляют возможность сохранения информации о состоянии, обеспечи-
вая дополнительный контекст для последующих вызовов методов.
Кроме того,
классы исключений легко могут адаптироваться и расширяться благодаря
наследованию. Другими словами, так как исключения определяются в виде
классов, все преимущества ООП, о которых мы узнали в шестой части книги,
доступны и при работе с исключениями."""

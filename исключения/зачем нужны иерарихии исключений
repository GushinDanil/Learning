В чем преимущества иерархий исключений?
Поскольку в примере предыдущего раздела имеется всего три возможных ис-
ключения, он действительно не может продемонстрировать все преимущества
применения классов исключений. На самом деле мы могли бы достичь того же
эффекта, указав в предложении except список имен исключений в круглых
скобках. Как это можно сделать, показано в файле stringexc.py:
try:
func()
except (General, Specific1, Specific2): # Перехватывает все эти исключения
...
Такой подход мог применяться и при использовании ныне отсутствующих
строковых исключений. Однако в случае разветвленных или глубоких иерар-
хий исключений, может оказаться гораздо проще перехватывать категории,
используя классы, чем перечислять в предложении except все исключения,
входящие в категорию. Кроме того, иерархии категорий можно расширять, до-
бавляя новые подклассы, не ломая при этом существующий программный код.
Предположим, что вы занимаетесь разработкой библиотеки, реализующей
функции обработки числовой информации, которая используется широким
кругом людей. Во время работы над библиотекой вы обнаруживаете две ситуа-
ции, которые могут приводить к таким ошибкам, как деление на ноль и пере-
полнение. Вы описываете эти ошибки как исключения, которые могут возбуж-
даться библиотекой:
# mathlib.py
class Divzero(Exception): pass
class Oflow(Exception): pass
def func():
...
raise Divzero()
Теперь те, кто будет использовать вашу библиотеку, станут стремиться оберты-
вать вызовы ваших функций или классов инструкцией try, чтобы перехваты-
вать два ваших исключения (если они не будут перехватывать их, эти исключе-
ния будут приводить к аварийному завершению программ):
# client.py
import mathlib
try:
    mathlib.func(...)
except (mathlib.Divzero, mathlib.Oflow):
    ...обработка и восстановление после ошибки...
Все работает просто замечательно и многие начинают использовать вашу би-
блиотеку. Однако шесть месяцев спустя вы, просматривая программный код
(программисты обычно склонны делать это), обнаруживаете еще одну ситуа-
цию, которая может приводить к другой ошибке – потере значимых разрядов,
после чего добавляете новое исключение:
# mathlib.py
class Divzero(Exception): pass
class Oflow(Exception): pass
class Uflow(Exception): pass
К сожалению, выпуском новой версии своей библиотеки вы создаете пробле-
му для тех, кто ею пользуется. Если они явно указывали имена ваших исклю-
чений, теперь им придется вернуться к своим программам и внести соответ-
ствующие изменения везде, где производятся обращения к вашей библиотеке,
чтобы включить вновь добавленное имя исключения:
# client.py
import mathlib
try:
    mathlib.func(...)
except (mathlib.Divzero, mathlib.Oflow, mathlib.Uflow):
    ...обработка и восстановление после ошибки...
Вероятно, это не конец света. Если ваша библиотека предназначена исключи-
тельно для внутреннего использования, вы могли бы внести все необходимые
изменения самостоятельно. Вы могли бы также написать сценарий, который
попытается ликвидировать проблему автоматически (едва ли такой сценарий
будет насчитывать более дюжины строк и на его создание уйдет совсем немного
времени). Однако если многим людям придется изменять все инструкции try
всякий раз, когда вы изменяете свой набор исключений, такая политика обнов-
ления определенно не будет расцениваться как самая вежливая.
Ваши пользователи могут попытаться избежать этой ловушки, определяя пу-
стые предложения except, которые перехватывают все исключения:
# client.py
try:
    mathlib.func(...)
except: # Перехватывать все исключения
    ...обработка и восстановление после ошибки...
Но при таком решении могут перехватываться посторонние исключения, даже
такие, которые вызваны опечатками в именах переменных, ошибками работы
с памятью, прерываниями работы программы с клавиатуры (Ctrl-C) и исклю-
чения, генерируемые программой при завершении, а для вас было бы нежела-
тельно, чтобы перехваченные исключения ошибочно классифицировались как
ошибки в библиотеке.
И действительно, в подобных ситуациях пользователи стремятся перехва-
тывать и обрабатывать только определенные исключения, возбуждаемые би-
блиотекой, как описывается в документации к ней – если в ходе работы би-
блиотечной функции возникает какое-то другое исключение, они чаще всего
расценивают это как ошибку в самой библиотеке (и обычно сообщают об этом
разработчику!). Как правило, при обработке исключений чем больше опреде-
ленности, тем лучше (к этой идее мы еще вернемся в разделе с описанием ти-
пичных проблем, в следующей главе).1
Так как же быть? Исключения на основе классов полностью ликвидируют
эту
проблему. Вместо того чтобы определять библиотечные исключения
как про-
стой набор независимых классов, их можно оформить в виде дерева классов
с одним общим суперклассом, охватывающим целую категорию
исключений:
# mathlib.py
class NumErr(Exception): pass
class Divzero(NumErr): pass
class Oflow(NumErr): pass
...
def func():
...
    raise Divzero()
При таком подходе пользователям вашей библиотеки достаточно будет
указать
общий суперкласс (то есть категорию), чтобы перехватывать
все исключения,
возбуждаемые библиотекой, причем, как существующие,
так и те, что появят-
ся в будущем:
# client.py
import mathlib
...
try:
    mathlib.func(...)
except mathlib.NumErr:
...вывод сообщения и восстановление после ошибки...
Когда вы опять вернетесь к работе над библиотекой, новые исключения можно
будет добавлять как новые подклассы от общего суперкласса:
# mathlib.py
...
class Uflow(NumErr): pass
В результате программный код пользователей, перехватывающий исключения
вашей библиотеки, останется работоспособным без каких-либо изменений. Вы
свободно сможете добавлять, удалять и изменять исключения произвольным
образом – пока клиенты используют имя суперкласса, они могут не беспокоить-
ся об изменениях в вашем наборе исключений. Другими словами, исключения
на основе классов лучше отвечают требованиям сопровождения, чем строки.
Кроме того, исключения
на основе классов могут поддерживать хранение
информации
о состоянии и наследование, что идеально подходит для крупных
программ. Однако чтобы разобраться в этих концепциях, нам сначала нужно
понять, как соотносятся классы исключений, опреджеляемые пользователем,
с классами встроенных исключений, которые они наследуют.
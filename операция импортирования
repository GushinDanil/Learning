Как работает импорт
В предыдущем разделе говорилось об импортировании модулей, но никак не
объяснялось, что происходит во время импорта. Так как в языке Python ин-
струкции импортирования составляют основу структуры программы, в этом
разделе более подробно будет рассмотрена операция импорта, чтобы сделать
представление об этом процессе менее абстрактным.
Некоторые программисты на языке C любят сравнивать инструкцию import
в языке Python с инструкцией #include, но они в корне неправы – импортиро-
вание в языке Python – это не просто включение текста одного файла в другой.
Это самые настоящие операции времени выполнения, которые выполняют сле-
дующие действия, когда программа впервые импортирует заданный файл:
1. Отыскивают файл модуля.
2. Компилируют в байт-код (если это необходимо).
3. Запускают программный код модуля, чтобы создать объекты, которые он
определяет.
Чтобы лучше понять, как протекает импорт модулей, мы исследуем все эти
действия по порядку. Примите во внимание, что все три действия выполня-
ются, только когда модуль впервые импортируется во время выполнения про-
граммы, – все последующие операции импорта того же модуля пропускают эти
действия и просто выбирают уже находящийся в памяти объект модуля. Тех-
нически это обеспечивается за счет того, что интерпретатор сохраняет инфор-
мацию о загруженных модулях в словаре с именем sys.modules и проверяет его
при выполнении каждой операции импортирования. Если модуль отсутствует
в словаре, выполняется трехэтапный процесс, описанный выше.
1. Поиск
Прежде всего, интерпретатор должен определить местонахождение файла мо-
дуля, указанного в инструкции import. Обратите внимание, что имена файлов
в инструкции import в примерах из предыдущих разделов указаны без рас-
ширения .py и без пути к каталогу: вместо записи в виде, например, import c:\
dir1\b.py, инструкция записывается просто – import b. Фактически допуска-
ется указывать лишь простые имена – путь к каталогу и расширение файла
должны быть опущены, потому что для поиска файла, соответствующего име-
ни, указанному в инструкции import, интерпретатор использует стандартный
путь поиска модулей.1 Поскольку это основная часть операции импорта, кото-
рую необходимо знать программистам, мы вернемся к ней чуть ниже.
2. Компиляция (если необходимо)
После того как в пути поиска модулей будет найден файл, соответствующий
имени в инструкции import, интерпретатор компилирует его в байт-код, если
это необходимо. (Мы рассматривали байт-код в главе 2.)
Интерпретатор проверяет время создания файла и пропускает этап компиля-
ции исходного программного кода, если файл с байт-кодом .pyc не старше, чем
соответствующий ему файл .py с исходным текстом. Кроме того, если Python
обнаружит в пути поиска только файл с байт-кодом и не найдет файл с исходным
текстом, он просто загрузит байт-код (это означает, что вы можете рас-
пространять свою программу исключительно в виде файлов с байт-кодом и не
передавать файлы с исходными текстами). Другими словами, этап компиля-
ции пропускается, если можно ускорить запуск программы. Если вы измените
исходный программный код, Python автоматически скомпилирует байт-код
при следующем запуске программы.
Обратите внимание, что компиляция выполняется в момент импортирования
файла. По этой причине файл .pyc с байт-кодом для главного файла программы
обычно не создается, если только он не был импортирован еще куда-нибудь –
файлы .pyc создаются только при импортировании файлов. Байт-код главного
файла программы создается в памяти компьютера, а байт-код импортирован-
ных файлов сохраняется в файлах для ускорения будущих операций импорта.
Главные файлы программ часто планируется исполнять непосредственно и ни-
куда их не импортировать. Позднее мы увидим, что существует возможность
создать файл, который будет играть роль как главного файла программы, так
и модуля, доступного для импорта. Такие файлы могут и исполняться, и им-
портироваться, поэтому для них создаются соответствующие файлы .pyc. Что-
бы разобраться с тем, как это получается, читайте обсуждение специальных
атрибутов __name__ и __main__ в главе 24.
3. Запуск
На последнем шаге операции импортирования производится запуск байт-кода
модуля. Все инструкции в файле модуля выполняются по порядку, сверху
вниз, и любые операции присваивания, которые встретятся на этом шаге, бу-
дут создавать атрибуты конечного объекта модуля. Таким образом, этот этап
выполнения создает все инструменты, которые определяются модулем. Напри-
мер, во время импортирования выполняются инструкции def в файле, которые
создают функции и присваивают их атрибутам модуля. После этого функции
могут вызываться из программы, выполнившей импорт.
На этом последнем шаге операции импортирования фактически запускается
программный код модуля, поэтому если программный код верхнего уровня
в файле модуля выполняет какие-нибудь действия, результаты этих действий
можно будет наблюдать во время импорта. Например, при импорте файла мож-
но будет наблюдать результат работы инструкций print на верхнем уровне мо
-дуля. Инструкции def просто определяют объекты для последующего исполь-
зования.
Как видите, во время импорта выполняется достаточно много работы – про-
изводится поиск файла, в случае необходимости запускается компилятор
и производится запуск программного кода. Вследствие этого любой заданный
модуль по умолчанию импортируется только один раз за все время работы про-
граммы. При повторных попытках импортировать модуль все три шага просто
пропускаются, и повторно используется модуль, уже загруженный в память.
Если вам потребуется еще раз импортировать файл, который уже был загру-
жен (например, чтобы обеспечить поддержку настроек, выполняемых пользо-
вателем), воспользуйтесь функцией imp.reload, с которой мы встретимся в сле-
дующей главе.1
Путь поиска модулей
Как уже отмечалось выше, для большинства программистов наиболее важным
в операции импортирования является первый этап – поиск файла импорти-
руемого модуля (раздел «1. Поиск»). Вам может потребоваться сообщить ин-
терпретатору, где следует искать импортируемые файлы, поэтому вы должны
знать, как получить доступ к пути поиска, чтобы дополнить его.
В большинстве случаев можно положиться на автоматически организованные
пути поиска модулей и вообще не настраивать этот путь. Однако, если вам по-
требуется импортировать модули из пользовательских каталогов, вам необхо-
димо будет знать, как работает путь поиска файлов, чтобы настроить его соот-
ветствующим образом. В общих чертах пути поиска модулей в языке Python
выбираются из объединенных данных следующих основных источников. Не-
которые из них предопределены, а некоторые можно настроить и тем самым
сообщить интерпретатору, где выполнять поиск:
1. Домашний каталог программы.
2. Содержимое переменной окружения PYTHONPATH (если таковая определена).
3. Каталоги стандартной библиотеки.
4. Содержимое любых файлов с расширением .pht (если таковые имеются).
В конечном итоге объединение этих четырех компонентов составляет sys.path –
список строк с именами каталогов, о котором я расскажу подробнее в следую-
щем разделе. Первый и третий компоненты пути поиска определяются авто-
матически, но так как интерпретатор при поиске использует данные всех этих
компонентов, от первого до последнего, то второй и четвертый компоненты
можно использовать для расширения пути поиска, включая в него свои соб-
ственные каталоги с исходными текстами. Далее описывается, как интерпре-
татор Python использует эти компоненты пути:Домашний каталог
В первую очередь интерпретатор ищет импортируемые файлы в домашнем
каталоге. В зависимости от того, как была запущена программа, это может
быть каталог, где находится главный файл программы. При работе в инте-
рактивном сеансе этот элемент содержит путь к каталогу, откуда была за-
пущена интерактивная оболочка (то есть текущий рабочий каталог).
Поскольку поиск в первую очередь всегда производится в этом каталоге,
если программа целиком располагается в одном каталоге, все операции
импорта будут выполнены автоматически, без необходимости настраивать
путь поиска. С другой стороны, из-за того, что поиск в первую очередь про-
изводится в этом каталоге, файлы, находящиеся в нем, могут сделать недо-
ступными модули с теми же именами, находящиеся в других каталогах, –
будьте внимательны, чтобы случайно не сделать недоступными библиотеч-
ные модули, которые могут потребоваться вашей программе.
Каталоги в PYTHONPATH
После этого поиск производится во всех каталогах, перечисленных в пере-
менной окружения PYTHONPATH, слева направо (если эта переменная вообще
установлена). В двух словах, переменная окружения PYTHONPATH – это про-
сто список имен каталогов, определяемых пользователем и системой, в ко-
торых располагаются файлы с программным кодом на языке Python. Вы
можете добавить в эту переменную все каталоги, откуда предполагается
импортировать модули, и интерпретатор будет использовать ваши настрой-
ки при создании пути поиска модулей.
Поскольку интерпретатор пытается отыскать файлы сначала в домашнем
каталоге, настройка этой переменной приобретает большое значение, толь-
ко когда необходимо импортировать модули, размещающиеся в разных ка-
талогах, – то есть, когда импортируемый файл хранится в каталоге, отлич-
ном от каталога, где располагается импортирующий файл. Вам наверняка
потребуется настраивать переменную окружения PYTHONPATH, как только вы
начнете писать большие программы, но на начальном этапе освоения языка
храните файлы всех своих модулей в каталоге, в котором вы работаете (то
есть в домашнем каталоге), и тогда операции импорта будут работать без не-
обходимости выполнять какие-либо настройки.
Каталоги стандартной библиотеки
Далее интерпретатор автоматически выполняет поиск в каталогах, куда
были установлены модули стандартной библиотеки. Так как эти каталоги
всегда участвуют в поиске, их можно не добавлять в переменную окруже-
ния PYTHONPATH, или включать в файлы с расширением .pth, о которых рас-
сказывается ниже.
Каталоги в файле .pth
Наконец, относительно новая особенность языка Python дает пользова-
телям возможность добавлять нужные каталоги в путь поиска модулей,
просто перечисляя их по одному в строке в текстовом файле, имя которого
оканчивается расширением .pth (от слова «path» – «путь»). Эти файлы пред-
ставляют собой расширенную возможность, имеющую отношение к про-
блеме установки, и мы не будем здесь подробно их обсуждать. Впрочем, они
могут служить альтернативой настройки переменной PYTHONPATH.
Текстовый файл со списком каталогов помещается в соответствующий ка-
талог и может играть примерно ту же роль, что и переменная окружения
PYTHONPATH. Например, если вы работаете в Python 3.0 под Windows, файл
с именем myconfig.pth можно поместить в главный каталог, куда был уста-
новлен Python 3.0 (например, C:\Python30), или в подкаталог site-packages
C:\Python30\Lib\site-packages стандартной библиотеки, что позволит рас-
ширить путь поиска модулей. В UNIX-подобных системах этот файл можно
поместить в каталог /usr/local/lib/python3.0/site-packages или /usr/local/lib/
site-python.
Обнаружив этот файл, интерпретатор добавит в конец пути поиска модулей
каталоги, перечисленные во всех строках файла, от первой до последней.
Интерпретатор выберет все имена каталогов во всех файлах .pth, которые
обнаружит, и отфильтрует повторяющиеся имена и имена несуществую-
щих каталогов. Поскольку это файлы, а не параметры настройки команд-
ной оболочки, они могут применяться ко всем пользователям системы, а не
только к одному пользователю или одной командной оболочке. Кроме того,
для некоторых пользователей процедура создания текстовых файлов вы-
глядит проще, чем настройка переменных окружения.
Эта особенность на практике более сложная, чем я описал. За дополни-
тельной информацией обращайтесь к руководству по библиотеке языка
Python, в частности к описанию модуля site, входящего в стандартную
библиотеку,
– этот модуль позволяет создавать файлы .pth и определять ме-
стоположение библиотек языка Python, а в документации к нему описыва-
ются каталоги, где вообще могут располагаться файлы .pth. Начинающим
я рекомендую использовать переменную окружения PYTHONPATH или един-
ственный файл .pth и только в том случае, если возникает необходимость
импортировать файлы из других каталогов. Наиболее часто файлы .pth
используются в сторонних библиотеках, которые обычно устанавливают
файлы .pth в каталог site-packages, чтобы исключить необходимость допол-
нительных настроек (система установки пакетов distutils, описываемая во
врезке ниже, позволяет автоматизировать многие операции, выполняемые
при установке).
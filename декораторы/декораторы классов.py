"""Декораторы функций оказались настолько удобны в обращении, что эта модель
была расширена в�Python��2.6 и 3.0 и теперь она позволяет применять декорато-
ры не только к функциям, но и к классам. В двух словах, декораторы классов
похожи на декораторы функций, но они запускаются после инструкции class,
чтобы повторно присвоить имя класса вызываемому объекту. Кроме того, они
могут использоваться для изменения классов сразу после их создания или до-
бавлять дополнительный слой логики уже после создания экземпляров. При
применении декоратора к классу программный код вида:"""


def decorator(AClass):
    return 1


@decorator
class A:
    pass


"""отображается в следующий эквивалент:"""


class A:
    A = decorator(A)


"""Декоратор класса может расширить функциональность самого класса или вер-
нуть объект, который будет перехватывать последующие попытки конструи-
рования экземпляров. Так, в примере из раздела «Подсчет экземпляров для
каждого класса с помощью методов класса» выше, мы могли бы использовать
этот прием для автоматического добавления в классы счетчика экземпляров
и любых других необходимых данных:"""

def count(aClass:type):
    print(aClass.__name__)
    aClass.numInstances = 0
    return aClass # Возвращает сам класс, а не обертку
@count
class Spam:
    ... # То же, что и Spam = count(Spam)
@count
class Sub(Spam):
    ... # Инструкция numInstances = 0 не нужна здесь
@count
class Other(Spam):
    ...




class tracer:
    def __init__(self, func):
        self.calls = 0
        self.func = func

    def __call__(self, *args):
        self.calls += 1
        print('call %s to %s' % (self.calls, self.func.__name__))
        self.func(*args)


@tracer  # То же, что и spam = tracer(spam)
def spam(a, b, c):
    print(a, b, c)


"""Функция spam передается декоратору tracer, поэтому, когда производится об-
ращение к оригинальному имени spam, в действительности вызывается метод
__call__ в классе. Этот метод подсчитывает и регистрирует вызовы, а затем вы-
зывает оригинальную обернутую функцию. Обратите внимание, как исполь-
зуется синтаксис аргумента *name для упаковывания и распаковывания аргу-
ментов, передаваемых функции, – благодаря этому данный декоратор может
использоваться для обертывания любой функции, с любым числом позицион-
ных аргументов.
В результате к оригинальной функции spam добавляется слой дополнительной
логики. Ниже приводится вывод, полученный от сценария, – первая строка
создана классом tracer, а вторая – функцией spam:
"""
spam(1, 2, 3)
spam('a', 'b', 'c')
spam(4, 5, 6)
"""Исследуйте программный код этого примера повнимательнее, чтобы вникнуть
в его суть. Итак, данный декоратор действует, как обычная функция, при-
нимающая позиционные аргументы, но он не возвращает результат вызова
декорируемой функции, не обрабатывает именованные аргументы и не может
декорировать методы классов (при декорировании методов метод __call__ мог
бы передавать только экземпляр класса tracer). Как мы узнаем в восьмой ча-
сти книги, существует множество способов декорирования функций, включая
вложенные инструкции def, – некоторые из них лучше подходят для декориро-
вания методов, чем способ, представленный здесь."""
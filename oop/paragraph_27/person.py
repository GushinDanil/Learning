import oop.paragraph_27.class_tools as show
'''
•• Person – класс, который представляет и обрабатывает информацию о людях
•• Manager – адаптированная версия класса Person, модифицирующая унасле-
дованное поведение
Попутно мы создадим экземпляры обоих классов и протестируем их возмож-
ности. По окончании я покажу вам отличный пример использования классов –
мы сохраним наши экземпляры в хранилище, в объектно-ориентированной
базе данных, обеспечивающей долговременной их хранение. Благодаря этому
вы сможете использовать программный код примера как шаблон для создания
своей собственной, полноценной базы данных, целиком написанной на языке
Python.'''

class Person(show.AttrDisplay):
    '''Выполнение операций за пределами класса, приводит к проблемам при сопро-
    вождении. поэтому для этого нужно использовать  методы как в примере ниже'''

    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def give_raise(self, percent):
        '''# если делаем какие-то манипуляции над объектом экземпляром класса
        то в методах а не за пределами инструкции class
        в этом и весь принцип инкапсуляции(спрятать логику операций за интерфейсами и тем
        самым добиться, чтобы каждая операция имела единственную реализацию
        в нашей программе. Благодаря такому подходу, если в дальнейшем нам по-
        требуется вносить какие-либо изменения, модифицировать программный код
        придется только в одном месте.)'''
        self.pay = int(self.pay * (1 + percent))# Изменения придется вносить
        # только в одном месте

    def last_name(self) -> str:

        return self.name.split()[-1]


class Manager(Person):  # наследование
    '''в этом классе описана концепция наследования'''
    def give_raise(self, percent, bonus=0.10):  # адаптация программного кода
        '''Проблема здесь самая обычная: всякий раз, когда вы копируете программный
        код, вы фактически усложняете его сопровождение в будущем. Представьте
        себе: из-за того, что мы скопировали оригинальную версию, нам придется из-
        менять программный код уже не в одном, а в двух местах, если позднее нам по-
       требуется (а это наверняка произойдет) изменить способ увеличения зарплаты.
        Это достаточно маленький и достаточно искусственный пример, тем не менее
        он наглядно демонстрирует общую проблему – всякий раз, когда у вас появ-
        ляется соблазн скопировать программный код, вам наверняка стоит поискать
        более правильный подход а не тот что ниже'''
        # self.pay = int(self.pay * (1 + percent+bonus)) неправильный подход
        '''В действительности нам требуется лишь дополнить оригинальный метод
        giveRaise, а не заменить его полностью. Правильный способ состоит в том, что-
        бы вызвать оригинальную версию с измененными аргументами, как показано
        ниже:'''
        Person.give_raise(self, percent + bonus)  # правильный(так проще будет производить изменения)
        '''Вывод
        На первый взгляд «правильная» версия мало чем отличается от предыдущей,
        «неправильной», но это может иметь огромное значение для сопровождения
        в будущем – поскольку основная логика работы метода giveRaise теперь нахо-
        дится только в одном месте (метод класса Person), в случае необходимости нам
        придется изменять всего одну версию. И действительно, такой способ расшире-
        ния метода более четко отражает наши намерения – нам требуется выполнить
        стандартную операцию giveRaise и просто добавить дополнительную премию.'''
        #self.give_raise(self,percent+bonus) ошибка: рекурсия причём бесконечная




    def __init__(self, name, pay):
        """С точки зрения реализа-
            ции, нам необходимо переопределить метод __init__ в классе Manager, чтобы он
            подставлял строку ‘mgr’ автоматически. Как и при адаптации метода giveRaise,
            нам также необходимо вызывать оригинальный метод __init__ из класса Person
            за счет обращения к имени класса, чтобы инициализировать остальные атри-
            буты объекта.
            В новой версии сценария, которая приводится ниже, мы создали новый кон-
            структор для класса Manager и изменили вызов, создающий объект tom, – теперь
            мы не передаем ему название должности ‘mgr’:"""
        Person.__init__(self, name, 'mgr', pay)


"""В действительности классы могут обладать еще более высокой гибкостью, чем
можно было бы предположить, исходя из нашего примера. В общем случае
классы могут наследовать, адаптировать и расширять существующую реали-
зацию суперклассов. В нашем примере мы все свое внимание сосредоточили на
адаптации имеющегося программного кода, однако мы точно так же могли бы
добавить в класс Manager уникальные методы, отсутствующие в классе Person,
если бы для класса Manager потребовалось реализовать нечто совсем иное (что
естественно вытекает из имени класса). Такую возможность иллюстрирует
следующий фрагмент. Здесь метод giveRaise переопределяет метод суперклас-
са, адаптируя его, а метод someThingElse является совершенно новым дополне-
нием к классу Manager:
class Person:
def lastName(self): ...
def giveRaise(self): ...
def __str__(self): ...
class Manager(Person): # Наследование
def giveRaise(self, ...): ... # Адаптация
def someThingElse(self, ...): ... # Расширение
tom = Manager()
tom.lastName() # Унаследованный метод
tom.giveRaise() # Адаптированная версия
tom.someThingElse() # Дополнительный метод
print(tom) # Унаследованный метод перегрузки"""


if __name__ == '__main__':
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job='dev', pay=50000)
    print(sue.last_name())
    print(bob.last_name())
    '''Что нам действительно сейчас необходимо, так это реализовать концепцию
    проектирования, которая называется инкапсуляцией. Идея инкапсуляции
    заключается в том, чтобы спрятать логику операций за интерфейсами и тем
    самым добиться, чтобы каждая операция имела единственную реализацию
    в нашей программе. Благодаря такому подходу, если в дальнейшем нам по-
    требуется вносить какие-либо изменения, модифицировать программный код
    придется только в одном месте. Кроме того, мы сможем изменять внутреннюю
    реализацию операции практически как угодно, не рискуя нарушить работо-
    способность программного кода, использующего ее.
    В терминах языка Python это означает, что мы должны реализовать операции
    над объектами в виде методов класса, а не разбрасывать их по всей програм-
    ме. Фактически возможность сосредоточить программный код в одном месте,
    устранить избыточность и тем самым упростить его сопровождение является
    одной из самых сильных сторон классов. Как дополнительное преимущество,
    оформление операций в виде методов позволяет применять их к любым экзем-
    плярам класса, а не только к тем, которые явно задействованы в обработке.
    На практике все это выглядит гораздо проще, чем в теории. В следующем ли-
    стинге мы переместили реализацию двух операций из программы в методы
    класса, добившись инкапсуляции. Давайте попутно изменим программный
    код самопроверки внизу файла и заменим в нем жестко запрограммированные
    операции вызовами методов:'''
    #sue.pay*=1.1 за всместо этого использовать идею инкапсуляции
    #bob.pay*=1.1
    sue.give_raise(2), bob.give_raise(1)# идея инкапсуляции реализована в этих методах
    print(bob)
    print(sue)
    tom = Manager('Tom Jones', 50000)
    tom.give_raise(.10)
    print(tom.last_name()) #опять
    print(tom)

'''Идея инкапсуляции
заключается в том, чтобы спрятать логику операций за интерфейсами и тем
самым добиться, чтобы каждая операция имела единственную реализацию
в нашей программе. Благодаря такому подходу, если в дальнейшем нам по-
требуется вносить какие-либо изменения, модифицировать программный код
придется только в одном месте.'''

'''По большому
счету, классы всего лишь добавляют дополнительный структурный уровень,
позволяющий организовать функции и данные в виде единого объекта и обе-
спечивающий возможность расширения'''

'''объединение объектов в составной объект'''


class Department:
    def __init__(self, *args):
        self.staff = list(args)

    def add_member(self, member):
        self.staff.append(member)

    def give_raise_all(self):
        for i in self.staff:
            i.give_raise(.10)

    def show_all(self):
        for i in self.staff:
            print(i)


if __name__ == '__main__':
    print('-' * 50)
    yandex = Department(sue, bob)
    yandex.add_member(tom)
    yandex.give_raise_all()
    yandex.show_all()

class addval:
    def __init__(self, value=0):
        self.data = value

    def __add__(self, other):
        return self.data + other


class addrepr(addval):
    def __repr__(self):
        return 'addrepr(%s)' % self.data


obj = addrepr()
obj + 5
print(obj)

'''Почему имеется два метода вывода? Дело вот в чем:
•• Встроенные функции print и str (а также ее внутренний эквивалент, кото-
рый используется функцией print) сначала пытаются использовать метод
__str__. Вообще этот метод должен возвращать строковое представление
объекта в удобном для пользователя виде.
•• Во всех остальных случаях используется метод __repr__: функцией авто-
матического вывода в интерактивной оболочке, функцией repr, при выводе
вложенных объектов, а также функциями print и str, когда в классе отсут-
ствует метод __str__. Вообще этот метод должен возвращать строку, которая
могла бы использоваться как программный код для воссоздания объекта
или содержать информацию, полезную для разработчиков.
Проще говоря, метод __repr__ используется везде, за исключением функций
print и str, если определен метод __str__. Однако, если метод __str__ отсутствует,
операции вывода будут использовать метод __repr__, но не наоборот – в осталь-
ных случаях, например, функцией автоматического вывода в интерактивной
оболочке всегда используется только метод __repr__; попытка использовать ме-
тод __str__ даже не предпринимается
Вследствие этого, если вам необходимо обеспечить единое отображение во всех
контекстах, лучше использовать метод __repr__. Однако, определив оба ме-
тода, вы обеспечите поддержку вывода в различных контекстах. Например,
перед конечным пользователем объект будет отображаться с помощью метода
__str__, а перед программистом будет выводиться информация более низкого
уровня с помощью метода __repr__
Здесь я должен сделать два примечания, касающиеся использования. Во-
первых, имейте в виду, что оба метода, __str__ и __repr__, должны возвращать
строки – возвращаемые значения других типов не преобразуются в строки
и вызывают ошибку, поэтому не забывайте выполнять преобразование в слу-
чае необходимости. Во-вторых, в зависимости от логики преобразования
в строковое представление, реализованной в контейнерном объекте(объекте), операция
вывода может вызывать метод __str__ только для объектов верхнего уровня –
вложенные объекты(элементы списка объектов) по-прежнему могут выводиться с применением их мето-
дов __repr__ или метода по умолчанию.
Чтобы обеспечить корректный вывод элементов контейнера как говорилось ранее нужно 
определить метод __repr__'''


class Printer:
    def __init__(self, val):
        self.val = val

    def __str__(self):
        return 'Printer(__str__): {0}'.format(self.val)

    def __repr__(self):
        return 'Printer(__repr__): {0}'.format(self.val)


obj1, obj2 = Printer(1), Printer(2)
print(obj1, obj2)  # вызовет __str__ так как используется обычная функция print
spisok = [obj1, obj2]

print(spisok)  # вызовет __repr__ так как используется объект контейнер

"""C технической точки зрения метод __add__, который использовался в примерах
выше, не поддерживает использование объектов экземпляров справа от опе-
ратора +. Чтобы реализовать поддержку таких выражений и тем самым обе-
спечить допустимость перестановки операндов, необходимо реализовать ме-
тод __radd__. Интерпретатор вызывает метод __radd__, только когда экземпляр
вашего класса появляется справа от оператора +, а объект слева не является
экземпляром вашего класса. Во всех других случаях, когда объект появляется
слева, вызывается метод __add__"""


class Commuter:
    def __init__(self, val):
        self.val = val

    def __add__(self, other):
        print('__add__')
        return self.val + other

    def __radd__(self, other):
        print('__radd__')
        return other + self.val


obj1 = Commuter(1)
obj2 = Commuter(2)

print(obj1 + 1)  # __add__
print(2 + obj2)  # __radd__

print(obj1 + obj2)

"""Обратите внимание на изменение порядка следования операндов в вызове ме-
тода __radd__: аргумент self в действительности находится справа от оператора
+, а аргумент other – слева. Кроме того, следует заметить, что здесь x и y – это эк-
земпляры одного и того же класса, – когда в выражении участвуют экземпля-
ры разных классов, интерпретатор предпочитает вызывать метод экземпляра,
расположенного слева. Когда выполняется операция сложения двух экземпля-
ров, интерпретатор вызывает метод __add__, который в свою очередь вызывает
метод __radd__, упрощая левый операнд."""

"""На практике, когда требуется распространить тип класса на результат, реали-
зация может оказаться сложнее: может оказаться необходимым выполнить
проверку типа, чтобы убедиться в безопасности операции преобразовании
и избежать вложенности. Так, если в следующем примере не выполнять про-
верку типа с помощью функции isinstance, дело может закончиться тем, что
мы получим экземпляр класса Commuter, значением атрибута val которого яв-
ляется другой экземпляр класса Commuter, – при сложении двух экземпляров,
когда метод __add__ вызывает метод __radd__:"""
print('-' * 50)


class Commuter2:
    def __init__(self, val):
        self.val = val

    def __add__(self, other):
        if isinstance(other, Commuter2):
            other = other.val
        return Commuter2(self.val + other)

    def __radd__(self, other):
        return Commuter2(other + self.val)

    def __str__(self):
        return "<Commuter2: {0}>".format(self.val)


obj1 = Commuter2(1)
obj2 = Commuter2(2)

print(obj1 + 10)  # Результат – другой экземпляр класса Commuter
print(10 + obj2)

obj3 = obj2 + obj1  # Нет вложения: не происходит рекурсивный вызов __radd__
print(obj3)
obj3+=obj3
print(obj3,'+=')
"""Чтобы обеспечить поддержку комбинированной операции сложения +=, увели-
чивающей значение экземпляра, необходимо реализовать метод __iadd__ или
__add__. Последний из них используется в случае отсутствия первого.
Фактически  класс Commuter2, представленный выше, уже поддерживает
операцию +=, однако с помощью метода __iadd__ можно реализовать более эф-
фективную операцию изменения самого экземпляра:"""

class Num:
    def __init__(self,val):
        self.val=val

    def __iadd__(self, other):
        self.val+=other
        return self

    def __str__(self):
        return '<Num: {0}>'.format(self.val)
obj=Num(0)
obj+=1
obj+=1
print(obj)

"""Любой двухместный оператор имеет похожий правосторонний метод пере-
грузки и метод, реализующий комбинированную операцию присваивания (на-
пример, __mul__, __rmul__ и __imul__). Правосторонние методы – это достаточно
сложная тема, и на практике они используются очень редко – к ним требуется
обращаться только в том случае, когда необходимо обеспечить для оператора
возможность перестановки операндов, и если вообще необходима реализа-
ция поддержки этого оператора. Например, эти методы могут использоваться
в классе Vector, но в таких классах, как Employee или Button, скорее всего, они
не нужны."""
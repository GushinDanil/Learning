class Life:
    def __init__(self,name="unknown"):
        print("Hello,",name)
        self.name=name

    def __del__(self):
        print("Goodbye",self.name)

brian=Life('Brian')
del brian # при удалении ссылки на объект экземпляр у нас удаляется объект экземпляр и вызывается метод __del__
"""Однако в языке Python
по целому ряду причин деструкторы используются не так часто, как в других
объектно-ориентированных языках программирования.
С одной стороны, интерпретатор автоматически освобождает память, занятую
экземпляром, поэтому нет нужды выполнять очистку памяти в деструкторах.1
С другой стороны, не всегда бывает возможным предсказать, когда произойдет
уничтожение экземпляра, поэтому часто лучше выполнять завершающие дей-
ствия в явно вызываемом методе (или в инструкции try/finally, которая описы-
вается в следующей части книги) – в некоторых случаях в системных таблицах
могут сохраняться ссылки на ваши объекты, что будет препятствовать вызову
деструктора


Фактически использование метода __del__ может осложняться
еще целым рядом причин. Например, исключения, возникшие
внутри этого метода, просто выводят сообщения в поток sys.
stderr (поток стандартного вывода сообщений об ошибках), а не
вызывают событие исключения, что вызвано непредсказуемо-
стью контекста, в котором метод запускается сборщиком мусора.
Кроме того, перекрестные (они же – циклические) ссылки между
объектами могут препятствовать сборке мусора, когда вы ожи-
даете ее, – механизм определения циклических ссылок, который
по умолчанию включен, способен автоматически собирать такие
объекты, но только если они не имеют методов __del__. Посколь-
ку в этом вопросе возникает слишком неясностей, мы не будем
дальше погружаться в детали – полный охват особенностей мето-
да __del__ и модуля сборки мусора gc (garbage collector) вы найде-
те в стандартном руководстве по языку Python."""


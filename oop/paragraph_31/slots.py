"""
Слоты экземпляров
Присваивая список имен атрибутов в виде строк специальному атрибуту __
slots__ класса, в классах нового стиля можно ограничить множество разре-
шенных атрибутов для экземпляров класса и оптимизировать использование
памяти и производительность.
Обычно этот атрибут устанавливается присваиванием последовательности
имен строк переменной __slots__ на верхнем уровне в инструкции class: только
имена, перечисленные в списке __slots__, смогут использоваться как атрибуты
экземпляра. Однако, как и в случае с любыми именами в языке Python, пре-
жде чем получить доступ к атрибутам экземпляра, им должны быть присвоены
значения, даже если они перечислены в списке __slots__. Например"""


class Limiter:
    __slots__ = ['name', 'age', 'job']  # По умолчанию наличие __slots__ означает

    # отсутствие __dict__

    def __init__(self):
        self.name = '_'
        self.age = 0
        self.job = '_'

    def __str__(self):
        return "<Limiter> Name: {0}, Age: {1}, Job: {2}".format(self.name, self.age, self.job)


obj = Limiter()
obj.name = 'Danil'
obj.age = 21
print(obj)
# obj.j = 'Jason'  # AttributeError: 'Limiter' object has no attribute 'j'(атрибут не указан в slots)
# print(obj.__dict__)  #AttributeError: 'Limiter' object has no attribute '__dict__'
"""Слоты – это своего рода нарушение динамической природы языка Python,
которая диктует, что операция присваивания может создавать любые имена.
Однако предполагается, что эта особенность поможет ликвидировать ошибки,
обусловленные простыми «опечатками» (обнаруживается попытка присваи-
вания атрибутам, отсутствующим в списке __slots__), и обеспечит некоторую
оптимизацию. Выделение памяти для словаря с именами атрибутов в каждом
экземпляре может оказаться слишком дорогим удовольствием, когда требу-
ется создать большое количество экземпляров, каждый из которых обладает
небольшим числом атрибутов. Для экономии пространства в памяти и повы-
шения производительности (получающийся выигрыш в значительной степени
зависит от самой программы) атрибуты, перечисленные в слотах, сохраняются
не в словаре, а в виде последовательности, что обеспечивает более высокую ско-
рость их поиска."""

"""экземпляры классов, где используются слоты, обычно не имеют
атрибут словаря __dict__ – вместо него пространство для атрибутов в экзем-
пляре выделяется с применением дескрипторов класса, которые будут рассма-
триваться в главе 37. Только имена, перечисленные в списке __slots__, смогут
использоваться как атрибуты экземпляра, однако значения этих атрибутов
могут извлекаться и изменяться обычными способами.Например:"""


class C:
    __slots__ = ['a', 'b']  # По умолчанию наличие __slots__ означает
    # отсутствие __dict__


x = C()
x.a = 5
print(x.a)

# print(x.__dict__)  # AttributeError: 'C' object has no attribute '__dict__'
"""Однако функции getattr() и setattr()
по-прежнему работают"""
print(getattr(x, 'a'))

setattr(x, 'b', 10)
print(x.b)
print('-' * 50)

"""В отсутствие словаря с пространством имен невозможно присвоить значения
атрибутам экземпляра, имена которых отсутствуют в списке слотов:"""


class D:
    __slots__ = ['a', 'b']

    def __init__(self, val):
        self.b = val
        # self.d=val # AttributeError: 'D' object has no attribute 'd'


x = D(20)
print(x.b)
print('-' * 50)

"""Однако возможность добавлять новые атрибуты все-таки существует – для это-
го необходимо включить имя __dict__ в список __slots__, разрешив тем самым
создать словарь с пространством имен. В этом случае действовать будут оба ме-
ханизма хранения имен, однако обобщенные инструменты, такие как getattr,
будут воспринимать их, как единое множество атрибутов:"""


class D:
    __slots__ = ['a', '__dict__']
    c = 3  # Атрибуты класса действуют как обычно

    def __init__(self, val):
        self.d = val  # Имя d будет добавлено в __dict__,
        # а не в __slots__


x = D(30)
print(getattr(x, 'd'))
print(x.__dict__)  # Некоторые объекты имеют оба атрибута, __dict__ и __slots__
print(x.__slots__)
print(x.c)

"""Если потребуется реализовать универсальный способ получения значений
всех атрибутов экземпляра, необходимо учесть наличие двух форм хранения
атрибутов или использовать функцию dir, которая дополнительно возвращает
все унаследованные атрибуты (для получения ключей в следующем примере
используется итератор словаря):"""
print('-' * 50)

for attr in list(getattr(x, "__dict__", [])) + getattr(x, "__slots__", []):
    """Поскольку любой из этих атрибутов может отсутствовать, более правильный
    способ выглядит, как показано ниже (функция getattr позволяет определять
    возвращаемое значение по умолчанию):"""
    print(attr, "=>", getattr(x, attr, []))

"""
•• Если подкласс наследует суперкласс, который не имеет атрибута __slots__,
атрибут __dict__ суперкласса будет доступен всегда, что делает бессмыслен-
ным использование атрибута __slots__ в подклассе.
•• Если класс определяет слот с тем же именем, что и суперкласс, версия име-
ни, объявленная в суперклассе, будет доступна только при непосредствен-
ном обращении к дескриптору в суперклассе.
•• Поскольку объявление __slots__ имеет значение только для класса, в кото-
ром оно присутствует, подклассы автоматически получат атрибут __dict__,
если не определят свой атрибут __slots__.
В общем для получения списка атрибутов экземпляра при использовании
слотов в нескольких классах может потребоваться: подъем по дереву классов
вручную, использование функции dir или подход, при котором имена слотов
рассматриваются, как совершенно отдельная категория имен:"""
print(50 * '-')


class E:
    __slots__ = ['c', 'd']


class D(E):
    __slots__ = ['__dict__', 'a']

D.t=5
x = D()
x.a = 1
x.b = 2
x.c = 3
x.y = 10
print(x.__slots__)  # получает слоты своего суперкласса
print(x.__dict__)   # хранит имена которых нету в слотах
print(x.c)  # не в __dict__ потому что определено в слотах суперкласса и слоты идут на объединение

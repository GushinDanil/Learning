"""В Python 3.0 методы, которым не передается ссылка на экземпляр и ко-
торые вызываются только через имя класса, не требуют объявления с помо-
щью функции staticmethod, но такое объявление обязательно для методов, ко-
торые предполагается вызывать через экземпляры.

Зачем нужны статические методы?
Иногда в программах бывает необходимо организовать обработку данных,
связанных с классами, а не с экземплярами. Например, следить за числом эк-
земпляров класса или вести список всех экземпляров класса, находящихся
в настоящий момент в памяти. Такого рода информация связана с классами
и должна обрабатываться на уровне класса, а не экземпляров. То есть такая
информация обычно сохраняется в самом классе и обрабатывается, независи-
мо от наличия экземпляров класса.
Для решения таких задач часто бывает достаточно простых функций, опреде-
ления которых находятся за пределами классов. Такие функции могут обра-
щаться к атрибутам класса через его имя – им требуется доступ только к дан-
ным класса и никогда – к экземплярам. Однако, чтобы теснее связать такой
программный код с классом и обеспечить возможность его адаптации с помощью
механизма наследования, будет лучше помещать такого рода функции внутрь
самого класса. Для этого нам и нужны методы класса, которые не ожидают по-
лучить аргумент self с экземпляром.
В языке Python для этих целей поддерживаются статические методы – про-
стые функции без аргумента self, вложенные в определение класса и пред-
назначенные для работы с атрибутами класса, а не экземпляра. Статические
методы никогда автоматически не получают ссылку self на экземпляр, неза-
висимо от того, вызываются они через имя класса или через экземпляр. Такие
методы обычно используются для обработки информации, имеющей отноше-
ние ко всем экземплярам, а не для реализации поведения экземпляров.


Методы класса
Кроме того, в языке Python поддерживается также понятие методов класса.
На практике методы класса используются реже, и в первом аргументе им ав-
томатически передается объект класса, независимо от того, вызываются они
через имя класса или через экземпляр. Такие методы могут получить доступ
к данным класса через аргумент self, даже когда они вызываются относитель-
но экземпляра. Обычные методы (которые формально называются методами
экземпляра) при вызове получают подразумеваемый экземпляр, а статические
методы и методы класса – нет.

•• В Python 3.0 от нас не требуется объявлять метод, как статический, если он
будет вызываться только через имя класса, но мы обязаны объявлять его
статическим, если он может вызываться через экземпляр."""


class Methods:
    numInstances = 0

    def __init__(self):
        Methods.numInstances += 1

    @staticmethod
    def printNumInstances():
        """Метод printNumInstances предназначен для обработки данных класса, а не эк-
        земпляров – эти данные являются общими для всех экземпляров. Вследствие
        этого нам необходима возможность вызывать его, не передавая ссылку на эк-
        земпляр. Действительно, зачем нам создавать новый экземпляр для получения
        числа экземпляров, ведь это изменит число экземпляров, которое мы пытаем-
        ся получить! Другими словами, нам нужен «статический» метод, не имеющий
        аргумента self."""
        print("Number of instances: ", Methods.numInstances)

    @classmethod
    def printNumInstances2(cls):
        print("Number of instances: ", cls.numInstances)


obj1 = Methods()
obj2 = Methods()
Methods.printNumInstances2()
obj3 = Methods()
Methods.printNumInstances()  # тут экземпляр не создаётся поэтому нету инкремента


class SubMethods(Methods):
    """Статические методы переопределяются"""

    @staticmethod
    def printNumInstances():
        Methods.printNumInstances()


SubMethods.printNumInstances()


class Sub(Methods):
    pass


a = Sub()
b = Sub()
Sub.printNumInstances()

"""
•• Применение статических методов, в которых явно указывается имя класса,
может оказаться более удачным решением для обработки данных класса.

•• Методы классов лучше подходят для обработки данных, которые могут от-
личаться для каждого конкретного класса в иерархии.

"""

print('-' * 50)
"""Например, для реализации счетчиков экземпляров каждого класса в отдель-
ности лучше подошли бы методы класса. В следующем примере суперкласс
определяет метод класса, управляющий информацией о состоянии, которая
отличается для разных классов в дереве, – подобно тому, как методы экзем-
пляра управляют информацией о состоянии экземпляров:"""


class Spam:
    numInstances = 0

    @classmethod
    def count(cls):
        cls.numInstances += 1

    def __init__(self):
        self.count()


class Sub(Spam):
    numInstances = 0

    def __init__(self):
        Sub.count()


class Other(Spam):
    numInstances = 0


obj1 = Spam()
obj2 = Spam()
obj3 = Spam()
print(Spam.numInstances)
"""метод класса позволил сохранить индивидуальный
подсчёт экземпляров для своего класса"""
print(Sub.numInstances)
z1, z2, z3 = Other(), Other(), Other()
print(Other.numInstances)


class A :
    attr='A'

class B(A):
    pass
class Y:
    attr='Y'
class C(A):
   attr = 'C'
class D(B,C):
    pass

obj=D()
print(obj.attr)
"""Это изменение процедуры поиска основано на предположении, что если вы до-
бавляете класс C в дерево ниже, это значит, что вы хотите получить его атри-
буты раньше, чем атрибуты класса A. Кроме того, это изменение предполагает,
что класс C всегда будет иметь возможность переопределить атрибуты класса A,
что, скорее всего, верно, когда пишется самостоятельный класс, но совсем не-
верно, когда в ромбоидальной схеме принимают участие классические клас-
сы, – вы можете даже не подозревать, что класс C может участвовать в подобной
схеме наследования, когда пишете его."""

print("-"*50)
"""Ниже уже иерархия не в виде ромба поэтому поиск уходит вверх а не вправо"""
class K:
    attr='K'
    pass
class A(K) :
    attr='A'

class B(A):
    attr = 'B'

class C(A):
    pass
class D(B,C):
    def print(self):
        """Проблема с предположениями в том, что они всего лишь предположения. Если
        такое отклонение в процедуре поиска кажется вам слишком трудным для за-
        поминания, или вам требуется более полное управление процедурой поиска,
        вы всегда можете произвести выбор желаемого атрибута из любого места в де-
        реве, выполнив присваивание или как-то иначе обозначив его там, где может
        возникнуть смешение классов:"""
        print(B.__bases__[0].__bases__[0].attr)
        print(C.attr)
        """Такой выбор путем присваивания или вызова в точках смешения может эф-
        фективно обезопасить ваш программный код от возможных различий между
        разными моделями классов. Явное разрешение конфликтов таким способом
        гарантирует, что правильная работа вашего программного кода не будет зави-
        сеть от версии Python в будущем (независимо от необходимости наследовать
        класс object или встроенные типы, чтобы использовать новую модель).
        НО ЛУЧШЕ ИСПОЛЬЗОВАТЬ СХЕМУ НАСЛЕДОВАНИЯ А НЕ ТАКИЕ ОБРАЩЕНИЯ НА ПРЯМУЮ Я СЧИТАЮ"""
    pass

obj=D()
obj.print()

print(obj.attr)
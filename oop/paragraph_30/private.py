"""Искаженные имена иногда ошибочно называют «частными атри-
бутами», но в действительности это всего лишь способ ограничить доступ
к именам в классе – искажение имен не предотвращает доступ из программно-
го кода, находящегося за пределами класса. Эта особенность в основном пред-
назначена, чтобы избежать конфликтов имен в экземплярах, а не для ограни-
чения доступа к именам, – поэтому искаженные имена лучше называть «псев-
дочастными», чем «частными».


Здесь описывается, как действует механизм искажения имен: имена внутри
инструкции class, которые начинаются с двух символов подчеркивания, но не
заканчиваются двумя символами подчеркивания, автоматически расширяют-
ся за счет включения имени вмещающего класса. Например, такое имя, как
__X, в классе с именем Spam автоматически изменится на _Spam__X: к оригиналь-
ному имени будет добавлен префикс, состоящий из символа подчеркивания
и имени вмещающего класса, и в результате будет получено достаточно уни-
кальное имя, которое не будет вступать в конфликт с именами в других клас-
сах иерархии.
Искажение имен происходит только внутри инструкций class и только для
имен, которые начинаются двумя символами подчеркивания. Однако это про-
исходит со всеми именами, которые начинаются двумя символами подчерки-
вания, включая имена методов и имена атрибутов экземпляров (например,
в нашем примере с классом Spam ссылка на атрибут экземпляра self.__X будет
преобразована в self._Spam__X). Поскольку экземпляр может получать атрибу-
ты более чем из одного класса, такое искажение позволяет избежать конфлик-
тов, но чтобы понять, как это происходит, нам нужно рассмотреть пример."""


class C1:
    """Например, предположим, что, когда программист писал класс, он предпола-
    гал, что экземпляры этого класса будут владеть атрибутом X. В методах класса
    выполняется присваивание этому атрибуту и позднее извлекается его значе-
    ние:"""

    def meth1(self):
        self.__x = 11

    def meth2(self):
        print(self.__x)


class C2:
    """Далее предположим, что другой программист, работающий отдельно, исходил
    из того же предположения, когда писал свой класс:"""

    def metha(self):
        self.__x = 22

    def methb(self):
        print(self.__x)


class C3(C1, C2):
    """Каждый класс по отдельности работает нормально. Проблема возникает, когда
    оба класса оказываются в одном дереве наследования:"""
    pass


"""Чтобы гарантировать принадлежность атрибута тому классу, который его ис-
пользует, достаточно в начале имени атрибута поставить два символа подчерки-
вания везде, где оно используется классом"""
obj = C3()  # У меня только один атрибут X!
obj.meth1()
obj.metha()
"""При наличии такой приставки '__' имена атрибутов X будут дополнены именами
их классов, прежде чем будут добавлены в экземпляр."""
print(obj._C1__x)
print(obj._C2__x)
"""Если вызвать функцию
dir, чтобы просмотреть перечень атрибутов экземпляра obj, или просмотреть
содержимое его словаря пространства имен после того, как атрибутам будут
присвоены значения, вы увидите измененные имена _C1__X и _C2__X, но не X."""
print(dir(obj))
print(obj.__dict__)
"""Этот прием помогает избежать конфликтов имен в экземплярах, но заметьте,
что он не обеспечивает настоящего сокрытия данных. Если вы знаете имя вме-
щающего класса, вы сможете обратиться к их атрибутам из любой точки про-
граммы, где имеется ссылка на экземпляр, используя для этого расширенное
имя (например, I._C1__X = 77). С другой стороны, эта особенность делает менее
вероятными случайные конфликты с существующими именами в классе."""

"""Псевдочастные атрибуты также удобно использовать в крупных проектах, так
как они позволяют избежать необходимости выдумывать новые имена мето-
дов, которые по ошибке могут переопределить методы, уже существующие
выше в дереве классов, и помогают снизить вероятность, что внутренние ме-
тоды окажутся переопределенными где-то ниже в дереве классов. Если метод
предназначен для использования только внутри класса, и этот класс может
наследовать или наследоваться другими классами, приставка из двух симво-
лов подчеркивания гарантирует, что имя этого метода не будет конфликтовать
с другими именами в дереве, особенно, когда используется прием множествен-
ного наследования:"""


class Super:
    def method(self):
        print("Super method")


class Tool:
    def __method(self):
        print("Tool __method")

    def other(self): self.__method()  # Используется внутренний метод


class Sub1(Tool, Super):
    def actions(self):
        self.method()  # Вызовет метод Super.method


class Sub2(Tool):
    """Кроме того, псевдочастные имена предотвращают возможность переопределе-
    ния внутренних методов в подклассах, как показано в классе Sub2."""
    def actions(self):
        self.method=11  # Не уничтожит Tool method (потому что его имя _Tool__method а не method)


Sub1().actions()

"""Еще раз отмечу, что эта особенность более полезна для крупных проектов,
в которых участвует несколько программистов, и только для отдельных имен.
Не торопитесь загромождать свой программный код лишними символами без
нужды – используйте эту особенность, только когда действительно необходи-
мо обеспечить принадлежность атрибута единственному классу. Для простых
программ этот прием будет излишеством."""

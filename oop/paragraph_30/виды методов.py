"""Обычные функции класса: без аргумента self
Попытка обращения к функциональному атрибуту класса через имя клас-
са возвращает объект function. Чтобы вызвать этот метод, не-
обходимо явно передать ему объект экземпляра в виде первого аргумента.

Связанные методы экземпляра: пара self + функция
Попытка обращения к функциональному атрибуту класса через имя экзем-
пляра возвращает объект связанного метода. Интерпретатор автоматиче-
ски упаковывает экземпляр с функцией в объект связанного метода, поэто-
му вам не требуется передавать экземпляр в вызов такого метода.



Кроме того, в версии 3.0 метод может вызываться без передачи ему ссылки на
экземпляр при условии, что сам метод не ожидает ее получить и вызывается
исключительно через обращение от имени класса. То есть в�Python�3.0 ссыл-
ка на экземпляр автоматически передается методу, только когда он вызывается относительно
экземпляра. При вызове метода через имя класса передавать ему экземпляр
требуется, только если он ожидает получить его:
Благодаря этому изменению в версии 3.0 отпала необходимость использовать
декоратор staticmethod, описываемый в следующей главе, для оформления ме-
тодов, которые не принимают аргумент self, вызываются только через имя
класса и никогда не вызываются относительно экземпляра, – такие методы
действуют как обычные функции, не получая аргумент с экземпляром.
"""

class Selfless:
    def __init__(self, data):
        self.data = data

    @staticmethod
    def selfless(arg1, arg2):  # Простая функция в 3.0
        return arg1 + arg2

    def normal(self, arg1, arg2):  # Ожидает получить экземпляр при вызове
        return self.data + arg1 + arg2


x = Selfless(2)

print(x.normal(3, 4))  # Экземпляр передается автоматически
print(Selfless.normal(x, 3, 4))  # Метод ожидает получить self:
# передается вручную
print(Selfless.selfless(3, 4))  # Вызов без экземпляра: работает в 3.0,
"""ошибки не возникнет, потому что в   версии 3.0  та-
кие методы интерпретируются, как простые функции, не требующие передачи
экземпляра. Эта особенность версии 3.0 уменьшает вероятность появления слу-
чайных ошибок (что если программист просто забудет передать экземпляр по
невнимательности?), но, с другой стороны, она позволяет использовать методы
как простые функции, при условии, что им не передается, и они не ожидают
получить аргумент «self» со ссылкой на экземпляр."""

"""Следующие два вызова завершатся ошибкой 
в первом случае (вызов относительно экземпляра) методу автоматиче-
ски будет передан экземпляр, которого он не ожидает, а во втором (вызов через
обращение к имени класса) метод не получит ожидаемый экземпляр:

>>> X.selfless(3, 4)
TypeError: selfless() takes exactly 2 positional arguments (3 given)
>>> Selfless.normal(3, 4)
TypeError: normal() takes exactly 3 positional arguments (2 given)"""


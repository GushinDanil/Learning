протокол итераций, – объект реализует метод __next__, который воз-
вращает следующее значение и возбуждает исключение StopIteration в конце
серии результатов.

Подобные объекты в языке Python считаются итерируемы-
ми. Любой такой объект доступен для сканирования с помощью цикла for или
других итерационных инструментов(констесктов,инструкций), потому что
все инструменты выполнения итераций создают итератор для итерируемого объекта ,
 вызывают метод __next__ в каждой итерации и определяют момент
выхода по исключению StopIteration.
Например
>>> for line in open(‘script1.py’): # Использовать итератор файла
... print(line.upper(), end=’’) # Вызывает метод __next__,
... # перехватывает исключение StopIteration
IMPORT SYS
PRINT(SYS.PATH)
X = 2
PRINT(2 ** 33)






С технической точки зрения итерационный протокол имеет еще одну сторону.
В самом начале цикл for получает итератор из итерируемого объекта, переда-
вая его встроенной функции iter, которая возвращает объект, имеющий тре-
буемый метод __next__. Это станет более очевидным, если посмотреть, на то,
как внутренние механизмы циклов for обрабатывают такие встроенные типы
последовательностей, как списки:
>>> L = [1, 2, 3]
>>> I = iter(L) # Получить объект-итератор
>>> I.__next__() # Вызвать __next__, чтобы перейти к следующему элементу
1
>>> I.__next__()
2
>>> I.__next__()
3
>>> I.__next__()
Traceback (most recent call last):
...текст сообщения об ошибке опущен...
StopIteration










Инструменты итераций в языке�Python вызывают эти функции автоматиче-
ски, однако мы также можем пользоваться ими при выполнении итераций
вручную. Следующий фрагмент наглядно демонстрирует эквивалентность ав-
томатического и ручного способов организации итераций.1
>>> L = [1, 2, 3]
>>>
>>> for X in L: # Автоматический способ выполнения итераций
... print(X ** 2, end=’ ‘) # Получает итератор, вызывает __next__,
... # обрабатывает исключение
1 4 9
>>> I = iter(L) # Ручной способ итераций: имитация цикла for
>>> while True:
... try: # Инструкция try обрабатывает исключения
... X = next(I) # Или I.__next__
... except StopIteration:
... break
... print(X ** 2, end=’ ‘)
...
1 4 9





На сегодняшний день язык Python более широко поддерживает отложенные
операции, чем в прошлом, – он предоставляет инструменты, позволяющие реа-
лизовать воспроизведение результатов по требованию, а не всех сразу. В част-
ности, существуют две языковые конструкции, откладывающие создание ре-
зультатов, когда это возможно:
•• Функции-генераторы – выглядят как обычные инструкции def, но для воз-
врата результатов по одному значению за раз используют инструкцию yield,
которая приостанавливает выполнение функции.
•• Выражения-генераторы – напоминают генераторы списков, о которых рас-
сказывалось в предыдущем разделе, но они не конструируют список с ре-
зультатами, а возвращают объект, который будет воспроизводить результа-
ты по требованию.
Поскольку ни одна из этих конструкций не создает сразу весь список с резуль-
татами, они позволяют экономить память и производить дополнительные вы-
числения между операциями получения результатов. Как мы увидим далее,
обе конструкции поддерживают такую возможность возврата результатов по
требованию за счет реализации протокола итераций, который мы изучили
в главе 14.





Возможно написать функцию, которая может возвращать значе-
ние, а позднее продолжить свою работу с того места, где она была приостанов-
лена. Такие функции известны как функции-генераторы, потому что они гене-
рируют последовательность значений с течением времени.


















И функции-генераторы, и выражения-генераторы имеют свои собственные
итераторы и потому поддерживают возможность лишь однократного выполне-
ния итераций – в отличие от некоторых встроенных типов, нет никакой воз-
можности получить несколько итераторов или выполнять позиционирование
итератора в множестве результатов. Например, для выражения-генератора из
предыдущего раздела итератором является сам генератор (фактически вызов
метода iter генератора не выполняет никаких действий):
>>> G = (c * 4 for c in ‘SPAM’)
>>> iter(G) is G # Итератором генератора является сам генератор:
True    # G имеет метод __next__
Если попробовать выполнить обход результатов вручную, с помощью несколь-
ких итераторов, окажется, что все они ссылаются на одну и ту же позицию
в последовательности результатов:
>>> G = (c * 4 for c in ‘SPAM’) # Создать новый генератор
>>> I1 = iter(G) # Выполнить итерацию вручную
>>> next(I1)
‘SSSS’
>>> next(I1)
‘PPPP’
>>> I2 = iter(G) # Второй итератор
>>> next(I2) # ссылается на ту же позицию!
‘AAAA’
Кроме того, как только итерации достигнут конца, все результаты окажутся
исчерпаны – чтобы выполнить повторный обход результатов, нам придется
создать новый генератор:
>>> list(I1) # Выберет остатки результаов в I1
[‘MMMM’]
>>> next(I2) # Другие итераторы также окажутся исчерпанными
StopIteration
>>> I3 = iter(G) # То же относится и к вновь созданным итераторам
>>> next(I3)
StopIteration
>>> I3 = iter(c * 4 for c in ‘SPAM’) # Создать новый генератор, чтобы
>>> next(I3) # выполнить повторный обход результатов
‘SSSS’
То же относится и к функциям-генераторам – следующий эквивалентный гене-
ратор, реализованный в виде функции, также обеспечивает возможность одно-
кратного выполнения итераций:
>>> def timesfour(S):
... for c in S:
... yield c * 4
...
>>> G = timesfour(‘spam’) # Функция-генератор действует точно так же
>>> iter(G) is G
True
>>> I1, I2 = iter(G), iter(G)
>>> next(I1)
‘ssss’
>>> next(I1)
‘pppp’
>>> next(I2) # I2 находится в той же позиции, что и I1
‘aaaa’





словари, например, имеют
собственные итераторы, которые во время итераций воспроизводят ключи:
>>> D = {‘a’:1, ‘b’:2, ‘c’:3}
>>> x = iter(D)
>>> next(x)
‘a’
>>> next(x)
‘c’




Например, функции-генераторы
и выражения-генераторы, а также встроенные функции, такие как map и zip,
возвращают итераторы однократного применения.
3. Почему так важно перенести обработку атрибутов в методы, а не выполнять
ее за пределами класса?
4. Почему лучше использовать прием адаптации с помощью подкласса, чем
копировать и изменять оригинальный программный код?
5. Почему лучше вызывать метод суперкласса для выполнения действий по
умолчанию, чем копировать и изменять его программный код в подклассе?
6. Почему лучше использовать такие инструменты, как __dict__, позволяю-
щие реализовать обобщенную обработку объектов, чем писать специализи-
рованный программный код для каждого отдельного класса?
7. Когда вообще может быть желательным вместо наследования использовать
прием встраивания одних объектов в другие?



3. Переносить обработку атрибутов в методы важно потому, что в этом случае
остается единственная копия программного кода, которую может потребо-
ваться изменить в будущем, а также потому, что методы могут вызываться
относительно любого экземпляра. Этот прием называется инкапсуляцией –
упаковывание логики в интерфейсы с целью упростить поддержку про-
граммного кода в будущем. Если этого не сделать, программный код будет
получаться избыточным, что повлечет за собой многократное увеличение
усилий, которые потребуется затратить на его сопровождение и дальней-
шее развитие в будущем.
4. Адаптация с помощью подклассов уменьшает усилия, затрачиваемые на
разработку. При использовании объектно-ориентированного стиля про-
граммирования мы адаптируем уже имеющийся программный код, а не
копируем и изменяем его. Это по-настоящему «самый основной» принцип
ООП – мы легко можем расширять возможности программного кода, на-
писанного ранее, создавая новые подклассы, и можем использовать то, что
уже имеется. Это намного лучше, чем каждый раз начинать все с самого
начала или создавать множество избыточных копий программного кода,
которые, вполне возможно, придется изменять в будущем.
5. Копирование и изменение существующего программного кода удваивает
объем работы, которую придется проделывать в будущем, независимо от
ситуации. Если в подклассе требуется выполнить какие-либо действия,
предусмотренные по умолчанию и реализованные в методе суперкласса,
будет намного лучше произвести вызов оригинального метода по имени су-
перкласса, чем копировать его программный код. То же справедливо и по
отношению к конструкторам суперклассов. Повторюсь, что копирование
программного кода создает избыточность, что может стать источником про-
блем при дальнейшем его развитии.
6. Обобщенные инструменты помогут избежать жестко запрограммирован-
ных решений, которые постоянно придется изменять по мере дальнейшего
развития класса. Обобщенный метод __str__ вывода, например, не придется
изменять каждый раз при добавлении нового атрибута экземпляра в кон-
структоре __init__. Кроме того, обобщенный метод вывода будет унаследо-
ван всеми классами, а в случае необходимости изменения придется вносить
только в одном месте – изменения в обобщенной версии автоматически бу-
дут отражаться на всех других классах, наследующих обобщенный класс.
Повторюсь еще раз, устранение избыточности в программном коде умень-
шает усилия, которые потребуется затратить на его развитие в будущем, –
это одно из основных преимуществ, которые несут в себе классы.
7. Наследование лучше использовать при разработке расширений с опорой на
непосредственную адаптацию (подобно тому, как класс Manager адаптирует
класс Person). Встраивание хорошо подходит в случаях, когда необходимо
объединить несколько объектов в единое целое и управлять ими с помощью
промежуточного класса. Механизм наследования позволяет многократно
использовать методы суперклассов, а метод встраивания – делегировать
вызовы методов другим классам. Наследование и встраивание не являются
взаимоисключающими методиками – нередко встречаются ситуации, ког-
да объекты встраиваются в контроллер и при этом сами могут адаптиро-
ваться с помощью механизма наследования.
"""для ручной итерации по объектам используют функцию next() но чисто для общего развития"""
f = open('C:\\Users\\admin-1\\PycharmProjects\\Learning\\web\\data\\results.txt')
print(next(f))

'''С технической точки зрения итерационный протокол имеет еще одну сторону.
В самом начале цикл for получает итератор из итерируемого объекта, переда-
вая его встроенной функции iter, которая возвращает объект, имеющий тре-
буемый метод __next__. Example: '''
L = [1, 2, 3]
i = iter(L)  # создание итератора для списка L приминительно к любому составному объекту

print(i.__next__())
print(i.__next__())
print(i.__next__())
# дальше ошибка

s = 'ew'

'''Интересно, что область влияния итерационного протокола в языке Python в на-
стоящее время гораздо шире, чем было продемонстрировано в примерах, – лю-
бые встроенные инструменты в языке Python, которые выполняют обход объ-
ектов слева направо, по определению используют итерационный протокол при
работе с объектами. Сюда относятся даже такие замысловатые инструменты,
как встроенные функции list и tuple (которые создают новые объекты последовательности из ите-
рируемых объектов), строковый метод join (который вставляет подстроку меж-
ду строками, содержащимися в итерируемом объекте) и даже операция при-
сваивания последовательностей. Благодаря этому все они могут применяться
к открытому файлу и автоматически выполнять чтение по одной строке за раз'''
print(list(open('text.txt')))
print(tuple(open('text.txt')))
print(set(open('text.txt')))

print('-' * 50)
print('&&'.join(open('text.txt')))

print('-' * 50)
a, *b = open('text.txt')
print(str(a).rstrip(), b)  # rstrip убрала \n


def count(a, b, c, d):
    print(a, b, c, d, sep='&')


'''специальнaя форму аргументов *arg, которая используется в вызо-
вах функций для распаковывания значений коллекций в отдельные аргумен-
ты.'''
count(1, 2, 3, 4)
count(*[1, 2, 3, 4])

print('-' * 50)
count(*open('text.txt'))

print('-' * 50)
R = range(10)  # range возвращает итератор, а не список
i = iter(R)
i2 = iter(R)
print(next(i))
print(next(i2))

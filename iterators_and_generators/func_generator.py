"""Возможно написать функцию, которая может возвращать значе-
ние, а позднее продолжить свою работу с того места, где она была приостанов-
лена.Такие функции известны как функции-генераторы, потому что они гене-
рируют последовательность значений с течением времени
Единственное отличие от обычных функциий состоит
в том, что они автоматически поддерживают протокол итераций и могут ис-
пользоваться в контексте итераций."""

"""Главное отличие функций-генераторов от обычных функций состоит в том, что
функция-генератор поставляет значение, а не возвращает его – инструкция
yield приостанавливает работу функции и передает значение вызывающей
программе, при этом сохраняется информация о состоянии, необходимая,
чтобы возобновить работу с того места, где она была приостановлена. Когда
функция-генератор возобновляет работу, ее выполнение продолжается с пер-
вой инструкции, следующей за инструкцией yield. Это позволяет функциям
воспроизводить последовательности значений в течение долгого времени, вме-
сто того чтобы создавать всю последовательность сразу и возвращать ее в виде
некоторой конструкции, такой как список."""


def genesquares(N):
    '''Эта функция поставляет значение и тем самым возвращает управление вызы-
    вающей программе на каждой итерации цикла – когда она возобновляет ра-
    боту, восстанавливается ее предыдущее состояние и управление передается
    непосредственно в точку, находящуюся сразу же за инструкцией yield. '''
    for i in range(N):
        yield i ** 2
'''Например, при использовании в заголовке цикла for управление 
возвращается функции на каждой итерации в точку,
находящуюся сразу же за инструкцией yield'''
for i in genesquares(5):
    print(i, end=' ')
print()

'''Здесь функция вернула объект-генератор, который поддерживает протокол
итераций, с которым мы познакомились в главе 14, – то есть имеет метод
__next)), который запускает функцию или возобновляет ее работу с места, от-
куда было поставлено последнее значение, а также возбуждает исключение
StopIteration по достижении конца последовательности значений.'''
x = genesquares(5)
print(x)
print(next(x))
print(next(x))
print(next(x))
print(next(x))
print(next(x))
'''дальше исключение StopIteration'''

'''генераторы предлагают лучшее решение с точки зрения использования
памяти и производительности. Они дают возможность избежать необходимо-
сти выполнять всю работу сразу, что особенно удобно, когда список результатов
имеет значительный объем или когда вычисление каждого значения занима-
ет продолжительное время. Генераторы распределяют время, необходимое на
создание всей последовательности значений, по отдельным итерациям цикла.
Кроме того, в более сложных случаях использования они обеспечивают про-
стую альтернативу сохранению состояния вручную между вызовами в объ-
ектах классов – в случае с генераторами переменные функций сохраняются
и восстанавливаются автоматически.'''

print('-' * 50)

'''С технической точки зрения yield в настоящее время является не инструкци-
ей, а выражением, которое возвращает элемент, передаваемый методу send (не-
смотря на то, что его можно использовать любым из двух способов – как yield
X или как A = (yield X)). Когда выражение yield помещается справа от оператора
присваивания, оно должно заключаться в круглые скобки, за исключением
случая, когда оно не является составной частью более крупного выражения.
Например, правильно будет написать X = yield Y, а также X = (yield Y) + 42.
При использовании расширенного протокола значения передаются генератору
G вызовом метода G.send(value). После этого программный код генератора возоб-
новляет работу, и выражение yield возвращает значение, полученное от метода
send. Когда вызывается обычный метод G.__next__() (или выполняется эквива-
лентный вызов next(G)), выражение yield возвращает None.'''


def gen():
    for i in range(5):
        '''это расширеный протокол yield у которого свои особенности'''

        x = yield i
        print(x)



g = gen()
print(g.__next__())
print(g.__next__())
print(g.send(55))
g.send(66)
g.send(77)

'''дальше исключение StopIteration'''



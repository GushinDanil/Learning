G = (x * 4 for x in "SPAM")
print(list(G))
print(G)

'''Эквивалентная функция-генератор содержит чуть больше программного кода,
но, будучи функцией, при необходимости способна вместить в себя больший
объем логики и использовать больший объем информации:'''


def timesfour(word):
    for i in word:
        yield i * 4


print(list(timesfour("SPAM")))


'''Обе разновидности генераторов поддерживают автоматическое и ручное управ-
ление итерациями – в предыдущем примере вызов функции list обеспечивает
автоматическое выполнение итераций, а в следующем примере демонстрирует-
ся выполнение итераций вручную:'''

G = ()



'''Внизу два примера
первый это получение уже готовой последовательности 
а создание итератора ненужный выпендрёж так как последовательность уже
сформирована

второй это получение объекта генератора 
который посылает по одному элементу а не как предыдущий пример всё сразу
поэтому и экономия памяти и тд'''
a=[i for i in [1,2,3]]
b=iter(a)
print(b.__next__())
print(b.__next__())
print(b.__next__())

'''здесь получение итератора ненадо потому 
что объект генератор и есть итератор(но не обычный) который поддерживает возможность
лишь однократного выполнения итераций'''
a=(i for i in [1,2,3]) #
print(a.__next__())
print(a.__next__())
print(list(a))

'''И функции-генераторы, и выражения-генераторы имеют свои собственные
итераторы и потому поддерживают возможность лишь однократного выполне-
ния итераций – в отличие от некоторых встроенных типов, нет никакой воз-
можности получить несколько итераторов или выполнять позиционирование
итератора в множестве результатов.
Если попробовать выполнить обход результатов вручную, с помощью несколь-
ких итераторов, окажется, что все они ссылаются на одну и ту же позицию
в последовательности результатов
Кроме того, как только итерации достигнут конца, все результаты окажутся
исчерпаны – чтобы выполнить повторный обход результатов, нам придется
создать новый генератор
То же относится и к функциям-генераторам'''

'''но например списки могут иметь множество независимых итераторов
и двигаться каждый по своему вдоль объекта списка'''

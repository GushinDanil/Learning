/**Составные и пустые инструкции
Подобно оператору запятой (раздел 4.13.5), объединяющему несколько выраже
ний в одно выражение, блок инструкций позволяет объединить несколько инст
рукций в одну составную инструкцию. Блок инструкций – это просто последова
тельность инструкций, заключенная в фигурные скобки. Таким образом, сле
дующие строки рассматриваются как одна инструкция и могут использоваться
везде, где интерпретатор JavaScript требует наличия единственной инструкции:*/
{
    x = Math.PI;
    cx = Math.cos(x);
    console.log("cos(π) = " + cx);
}
/**Здесь есть несколько аспектов, на которые следует обратить внимание. Во-пер
вых, составная инструкция не завершается точкой с запятой. Отдельные инст
рукции внутри блока завершаются точками с запятой, однако сам блок – нет. Во-
вторых, строки внутри блока оформлены с отступами относительно фигурных
скобок, окружающих их. Это не является обязательным требованием, но подоб
ное оформление программного кода упрощает его чтение и понимание. Наконец,
напомню, что в языке JavaScript не поддерживается область видимости блока,
поэтому переменные, объявленные внутри блока, не являются частными по отно
шению к этому блоку (подробности смотрите в разделе 3.10.1).
Объединение инструкций в более крупные блоки инструкций используется в язы
ке JavaScript повсеместно. Подобно тому как выражения часто включают другие
подвыражения, многие инструкции JavaScript могут содержать другие инструк
ции. Формальный синтаксис языка JavaScript обычно позволяет использовать не
более одной подынструкции. Например, синтаксис инструкции цикла while вклю
чает единственную подынструкцию, которая служит телом цикла. Блоки инст
рукций позволяют помещать любое количество инструкций там, где требуется
наличие единственной подынструкции.
Составные инструкции позволяют использовать множество инструкций там, где
синтаксис JavaScript допускает только одну инструкцию. Пустая инструкция
действует противоположным образом: она позволяет не вставлять инструкции
там, где они необходимы. Пустая инструкция имеет следующий вид:
;
Встретив пустую инструкцию, интерпретатор JavaScript не выполняет никаких
действий. Пустая инструкция может оказаться полезной, когда требуется соз
дать цикл с пустым телом. Взгляните на следующий цикл for (циклы for будут
рассматриваться в разделе 5.5.3):*/
// Инициализировать массив a
var a=[1,2,3];
for(i = 0; i < a.length; a[i++] = 0) ;
console.log(a)

var a=[1,2,3];
for( i in a)
    a[i]=0
console.log(a)

/**В этом цикле вся работа выполняется выражением a[i++] = 0, и тело цикла здесь
не требуется. Однако синтаксис JavaScript требует, чтобы цикл имел тело, поэто
му здесь использована пустая инструкция – просто точка с запятой.
Обратите внимание, что ошибочное добавление точки с запятой после закрываю
щей круглой скобки в инструкции for, while или if может вызывать появление
досадных ошибок, которые сложно обнаружить. Например, следующий фраг
мент наверняка будет делать не совсем то, что предполагал автор:*/
var b=0;
if ((a == 0) || (b == 0));     // Ой! Эта строка ничего не делает...
    o = null;                  // а эта будет выполняться всегда.112
/**
Если вы собираетесь намеренно использовать пустую инструкцию, нелишним бу
дет добавить комментарий, поясняющий ваши намерения. Например:*/
for(i = 0; i < a.length; a[i++] = 0) /* пустое тело цикла */ ;

/**
 * Любое из трех выражений цикла for может быть опущено, но две точки с запятой
 * являются обязательными. Если опустить выражение проверки, цикл будет повто
 * ряться вечно, и форма записи for(;;) является еще одним способом написать бес
 * конечный цикл, подобно while(true).
 *
 */

for(var i = 0, j=10; i < 10; i++,j--)

    console.log(i*j);


/**
 * Инструкции объявления функций могут находиться в JavaScript-коде верхнего
 * уровня или быть вложенными в определения других функций, но только на
 * «верхнем уровне», т. е. объявления функций не могут находиться внутри инст
 * рукций if, циклов while или любых других конструкций. Из-за такого ограниче
 * ния, накладываемого на объявления функций, спецификация ECMAScript не
 * относит объявления функций к истинным инструкциям. Некоторые реализации
 * JavaScript позволяют вставлять объявления функций в любые инструкции, но
 * разные реализации по-разному обрабатывают эти случаи, поэтому включение
 * объявлений функций в другие инструкции снижает переносимость программ.
 * Инструкция объявления функции отличается от выражения тем, что она вклю
 * чает имя функции. Обе формы создают новый объект функции, но инструкция
 * объявления функции при этом объявляет имя функции – переменную, которой
 * присваивается объект функции. Подобно переменным, объявляемым с помощью
 * инструкции var, объявления функций, созданные с помощью инструкции functi
 * on, неявно «поднимаются» в начало содержащего их сценария или функции, по
 * этому они видимы из любого места в сценарии или функции. Однако при исполь
 * зовании инструкции var поднимается только объявление переменной, а инициа
 * лизация остается там, куда ее поместил программист. В случае же с инструкцией
 * function поднимается не только имя функции, но и ее тело: все функции в сцена
 * рии или все функции, вложенные в функцию, будут объявлены до того, как нач
 * нется выполнение программного кода. Это означает, что функцию можно вызвать
 * еще до того, как она будет объявлена.
 * Подобно инструкции var, инструкции объявления функций создают переменные,
 * которые невозможно удалить. Однако эти переменные доступны не только для
 * чтения – им можно присвоить другие значения.
 * чтения – им можно присвоить другие значения.
 */
'В ПАЙТОНЕ МОЖНО ВЛОЖИТЬ ФУНКЦИЮ В ЦИКЛ ИЛИ УСЛОВНЫЙ КОНТЕКСТ(ТОЕСТЬ ИНСТРУКЦИЮ ФУНКЦИЮЮ В ЛЮБУЮ ИНСТРУКЦИЮ) ' +
'А В ДЖС ЭТОГО СДЕЛАТЬ НЕЛЬЗЯ' +
'НО ЗАТО В ДЖС МОЖНО ВЫЗВАТЬ ФУНКЦИЮ ЕЩЁ ДО ЕЁ ОПРЕДЕЛЕНИЯ НО ОНА ОБЯЗАТЕЛЬНА ДОЛЖНА БЫТЬ ОБЪЯВЛЕНА НИЖЕ' +
'ЧИТАЙ НА ВСЯКИЙ СЛУЧАЙ СТАТЬЮ ВЫШЕ' +
'ТЕМ ВРЕМЕНЕМ ПРИМЕРЫ ЭТОГО НИЖЕ:'
f1()
function f1() {
    console.log(message) // значение undefined но это не будет ошибкой
    var message='I love this'
    console.log('LOOK AT THIS');
}

// SWITCH

    switch (true) { // при сравнении с кейсами используется оператор идентичности(===) а не равенства (==)
        case 'true':
            console.log('case \'true\' : worked')
        case 1:
            console.log('case 1 : worked')
        case true:
            console.log('case true : worked')
        default:
            console.log('hui znaet')
    }
/**
 * Когда выполняется инструкция switch, она вычисляет значение выраже
 * ния, а затем ищет метку case, соответствующую этому значению (соответствие оп
 * ределяется с помощью оператора идентичности ===). Если метка найдена, выпол
 * няется блок кода, начиная с первой инструкции, следующей за меткой case. Если
 * метка case с соответствующим значением не найдена, выполнение начинается
 * с первой инструкции, следующей за специальной меткой default:. Если метка
 * default: отсутствует, блок инструкции switch пропускается целиком.
 * Обратите внимание на ключевое слово break в конце каждого блока case. Инструк
 * ция break, описываемая далее в этой главе, приводит к передаче управления в ко
 * нец инструкции switch и продолжению выполнения инструкций, следующих да
 * лее. Конструкции case в инструкции switch задают только начальную точку вы
 * полняемого программного кода, но не задают никаких конечных точек. В случае
 * отсутствия инструкций break инструкция switch начнет выполнение блока кода
 * с меткой case, соответствующей значению выражения, и продолжит выполнение ин
 * струкций до тех пор, пока не дойдет до конца блока. В редких случаях это полез
 * но для написания программного кода, который переходит от одной метки case
 * к следующей, но в 99% случаев следует аккуратно завершать каждый блок case
 * инструкцией break. (При использовании switch внутри функции вместо break мож
 * но использовать инструкцию return. Обе эти инструкции служат для завершения
 * работы инструкции switch и предотвращения перехода к следующей метке case.)
 */

    switch (typeof 'pizdec') { // при сравнении с кейсами используется оператор идентичности(===) а не равенства (==)
        case 'number':
            console.log(1)
            break;
        case 'boolean':
            console.log(true)
            break;
        case 'string':
            console.log('string')
            break;
        default:
            console.log('hui znaet')
            break
    }

/**
 * for/in в js отличается от пайтон тем что он возвращает не значения объекта массива а его индексы
 * в то время как в пайтоне надо использовать функци  enumarate для этого
 * по умолчанию он возвращает значение массива
  */
for(i in a) console.log(i);

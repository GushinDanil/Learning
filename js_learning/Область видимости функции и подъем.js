/*В некоторых C-подобных языках программирования каждый блок программно
го кода внутри фигурных скобок имеет свою собственную область видимости,
а переменные, объявленные внутри этих блоков, невидимы за их пределами. Эта
особенность называется областью видимости блока, но она не поддерживается
в языке JavaScript. Вместо этого в JavaScript используется такое понятие, как
область видимости функции: переменные, объявленные внутри функции, дос
тупны внутри функции, где они объявлены, а также внутри всех функций, вло
женных в эту функцию.
В следующем фрагменте переменные i, j и k объявляются в разных местах, но все
они имеют одну и ту же область видимости – все три переменные доступны из лю
бого места в теле функции:*/
function test(o) {
    var i = 0;                       //i определена в теле всей функции
    if (typeof o == "object") {
        var j = 0;                   //j определена везде, не только в блоке
        for(var k=0; k < 10; k++) {  //k определена везде, не только в цикле
            console.log(k);          //выведет числа от 0 до 9
        }
        console.log(k);              //k по-прежнему определена: выведет 10
    }
    console.log(j);                  //j определена, но может быть неинициализирована
}

/*
Область видимости функции в языке JavaScript подразумевает, что все перемен
ные, объявленные внутри функции, видимы везде в теле функции. Самое инте
ресное, что переменные оказываются видимыми еще до того, как будут объявле
ны. Эта особенность JavaScript неофициально называется подъемом: программ
ный код JavaScript ведет себя так, как если бы все объявления переменных внутри
функции (без присваивания инициализирующих значений) «поднимались»
в начало функции.
В отличие от функций объявления классов не поднимаются, поэтому объ
явленный таким способом класс нельзя использовать в коде, находящемся до
объявления.
Рассмотрим следующий фрагмент:*/
var scope = "global";
function f() {
    console.log(scope);  // Выведет "undefined", а не "global"
    var scope = "local"; // Инициализируется здесь, а определена везде
    console.log(scope);  // Выведет "local"
}
/*
Можно было бы подумать, что первая инструкция внутри функции должна вы
вести слово «global», потому что инструкция var с объявлением локальной пере
менной еще не была выполнена. Однако вследствие действия правил области ви
димости функции выводится совсем другое значение. Локальная переменная оп
ределена во всем теле функции, а это означает, что глобальная переменная с тем
же именем оказывается скрытой для всей функции. Хотя локальная переменная
определена во всем теле функции, она остается неинициализированной до вы
полнения инструкции var. То есть функция выше эквивалентна реализации, при
веденной ниже, в которой объявление переменной «поднято» в начало функции,
а инициализация переменной выполняется там же, где и раньше:3.10. Область видимости переменной*/
function f() {
    var scope;           //Объявление локальной переменной в начале функции
    console.log(scope);  //Здесь она доступна, но имеет значение "undefined"
    scope = "local";     //Здесь она инициализируется и получает свое значение
    console.log(scope);  //А здесь она имеет ожидаемое значение
}
/*
В языках программирования, где поддерживаются области видимости блоков,
рекомендуется объявлять переменные как можно ближе к тому месту, где они ис
пользуются, а область видимости делать как можно более узкой. Поскольку в
JavaScript не поддерживаются области видимости блоков, некоторые программи
сты стремятся объявлять все переменные в начале функции, а не рядом с местом,
где они используются. Такой подход позволяет более точно отражать истинную
область видимости переменных в программном коде.
*/


'В ПАЙТОН ОТСУТСТВУЕТ ПОНЯТИЕ ОБЛАСТИ ВИДИМОСТИ БЛОКА КАК И В ДЖС И ТАК ЖЕ КАК И В ДЖС ' +
'ПРИСУТСТВУЕТ ПОНЯТИЕ ОБЛАСТИ ВИДИМОСТИ ФУНКЦИИ'
'В ПАЙТОН ПОДЪЁМ НЕ ВОЗМОЖЕН' +
'ТАМ К ПЕРЕМЕННЫМ И ФУНКЦИЯМ МОЖНО ОБРАТИТЬСЯ ТОЛЬКО ПОСЛЕ ИХ ИНИЦИАЛИЗАЦИИ ' +
'ТАК КАК ТАМ ОТСУТСТВУЕТ ОБЪЯВЛЕНИЯ И ЕСТЬ ИСКЛЮЧИТЕЛЬНО ТОЛЬКО ИНИЦИАЛИЗАЦИЯ'